{"ast":null,"code":"import * as t from \"rematrix\";\nvar e = function (t) {\n    return \"number\" == typeof t;\n  },\n  i = function (t) {\n    return \"function\" == typeof t;\n  },\n  n = function (t) {\n    return \"[object Object]\" === Object.prototype.toString.call(t);\n  },\n  r = function (t) {\n    return Array.prototype.slice.apply(t);\n  },\n  s = function (t) {\n    var e = t.reduce(function (t, e) {\n      return t[e] = (t[e] || 0) + 1, t;\n    }, {});\n    return Object.keys(e).filter(function (t) {\n      return e[t] > 1;\n    });\n  };\nfunction a(t) {\n  return [].slice.call(arguments, 1).forEach(function (e) {\n    if (e) for (var i in e) Object.prototype.hasOwnProperty.call(e, i) && (t[i] = e[i]);\n  }), t;\n}\nvar o,\n  l = function (t, e, i) {\n    return t + (e - t) * i;\n  },\n  p = {\n    __proto__: null,\n    isNumber: e,\n    isFunction: i,\n    isObject: n,\n    toArray: r,\n    getDuplicateValsAsStrings: s,\n    assign: a,\n    tweenProp: l\n  },\n  c = \"data-flip-id\",\n  u = \"data-inverse-flip-id\",\n  d = \"data-portal-key\",\n  f = \"data-exit-container\",\n  h = {\n    __proto__: null,\n    DATA_FLIP_ID: c,\n    DATA_INVERSE_FLIP_ID: u,\n    DATA_FLIP_COMPONENT_ID: \"data-flip-component-id\",\n    DATA_FLIP_CONFIG: \"data-flip-config\",\n    DATA_PORTAL_KEY: d,\n    DATA_EXIT_CONTAINER: f\n  },\n  g = {\n    noWobble: {\n      stiffness: 200,\n      damping: 26\n    },\n    gentle: {\n      stiffness: 120,\n      damping: 14\n    },\n    veryGentle: {\n      stiffness: 130,\n      damping: 17\n    },\n    wobbly: {\n      stiffness: 180,\n      damping: 12\n    },\n    stiff: {\n      stiffness: 260,\n      damping: 26\n    }\n  },\n  m = function (t) {\n    return n(t) ? t : Object.keys(g).indexOf(t) > -1 ? g[t] : {};\n  };\n\"undefined\" != typeof window && (o = window.requestAnimationFrame);\nvar v = o = o || function (t) {\n    window.setTimeout(t, 1e3 / 60);\n  },\n  y = Date.now(),\n  _ = \"object\" == typeof performance && \"function\" == typeof performance.now ? function () {\n    return performance.now();\n  } : function () {\n    return Date.now() - y;\n  };\nfunction S(t, e) {\n  var i = t.indexOf(e);\n  -1 !== i && t.splice(i, 1);\n}\nvar E = /*#__PURE__*/function () {\n    function t() {}\n    return t.prototype.run = function () {\n      var t = this;\n      v(function () {\n        t.springSystem.loop(_());\n      });\n    }, t;\n  }(),\n  A = function () {\n    this.position = 0, this.velocity = 0;\n  },\n  C = 0,\n  b = .001,\n  I = /*#__PURE__*/function () {\n    function t(t) {\n      this._id = \"s\" + C++, this._springSystem = t, this.listeners = [], this._startValue = 0, this._currentState = new A(), this._displacementFromRestThreshold = .001, this._endValue = 0, this._overshootClampingEnabled = !1, this._previousState = new A(), this._restSpeedThreshold = .001, this._tempState = new A(), this._timeAccumulator = 0, this._wasAtRest = !0, this._cachedSpringConfig = {};\n    }\n    var e = t.prototype;\n    return e.getId = function () {\n      return this._id;\n    }, e.destroy = function () {\n      this.listeners = [], this._springSystem.deregisterSpring(this);\n    }, e.setSpringConfig = function (t) {\n      return this._springConfig = t, this;\n    }, e.getCurrentValue = function () {\n      return this._currentState.position;\n    }, e.getDisplacementDistanceForState = function (t) {\n      return Math.abs(this._endValue - t.position);\n    }, e.setEndValue = function (t) {\n      if (t === this._endValue) return this;\n      if (this.prevEndValue = t, this._endValue === t && this.isAtRest()) return this;\n      this._startValue = this.getCurrentValue(), this._endValue = t, this._springSystem.activateSpring(this.getId());\n      for (var e = 0, i = this.listeners.length; e < i; e++) {\n        var n = this.listeners[e].onSpringEndStateChange;\n        n && n(this);\n      }\n      return this;\n    }, e.setVelocity = function (t) {\n      return t === this._currentState.velocity || (this._currentState.velocity = t, this._springSystem.activateSpring(this.getId())), this;\n    }, e.setCurrentValue = function (t) {\n      this._startValue = t, this._currentState.position = t;\n      for (var e = 0, i = this.listeners.length; e < i; e++) {\n        var n = this.listeners[e];\n        n.onSpringUpdate && n.onSpringUpdate(this);\n      }\n      return this;\n    }, e.setAtRest = function () {\n      return this._endValue = this._currentState.position, this._tempState.position = this._currentState.position, this._currentState.velocity = 0, this;\n    }, e.setOvershootClampingEnabled = function (t) {\n      return this._overshootClampingEnabled = t, this;\n    }, e.isOvershooting = function () {\n      var t = this._startValue,\n        e = this._endValue;\n      return this._springConfig.tension > 0 && (t < e && this.getCurrentValue() > e || t > e && this.getCurrentValue() < e);\n    }, e.advance = function (t, e) {\n      var i = this.isAtRest();\n      if (!i || !this._wasAtRest) {\n        var n = e;\n        e > .064 && (n = .064), this._timeAccumulator += n;\n        for (var r, s, a, o, l, p, c = this._springConfig.tension, u = this._springConfig.friction, d = this._currentState.position, f = this._currentState.velocity, h = this._tempState.position, g = this._tempState.velocity; this._timeAccumulator >= b;) this._timeAccumulator -= b, this._timeAccumulator < b && (this._previousState.position = d, this._previousState.velocity = f), s = c * (this._endValue - h) - u * f, o = c * (this._endValue - (h = d + (r = f) * b * .5)) - u * (g = f + s * b * .5), p = c * (this._endValue - (h = d + (a = g) * b * .5)) - u * (g = f + o * b * .5), h = d + (l = g) * b, d += 1 / 6 * (r + 2 * (a + l) + (g = f + p * b)) * b, f += 1 / 6 * (s + 2 * (o + p) + (c * (this._endValue - h) - u * g)) * b;\n        this._tempState.position = h, this._tempState.velocity = g, this._currentState.position = d, this._currentState.velocity = f, this._timeAccumulator > 0 && this._interpolate(this._timeAccumulator / b), (this.isAtRest() || this._overshootClampingEnabled && this.isOvershooting()) && (this._springConfig.tension > 0 ? (this._startValue = this._endValue, this._currentState.position = this._endValue) : (this._endValue = this._currentState.position, this._startValue = this._endValue), this.setVelocity(0), i = !0);\n        var m = !1;\n        this._wasAtRest && (this._wasAtRest = !1, m = !0);\n        var v = !1;\n        i && (this._wasAtRest = !0, v = !0), this.notifyPositionUpdated(m, v);\n      }\n    }, e.notifyPositionUpdated = function (t, e) {\n      var i = this;\n      this.listeners.filter(Boolean).forEach(function (n) {\n        t && n.onSpringActivate && !i._onActivateCalled && (n.onSpringActivate(i), i._onActivateCalled = !0), n.onSpringUpdate && n.onSpringUpdate(i), e && n.onSpringAtRest && n.onSpringAtRest(i);\n      });\n    }, e.systemShouldAdvance = function () {\n      return !this.isAtRest() || !this.wasAtRest();\n    }, e.wasAtRest = function () {\n      return this._wasAtRest;\n    }, e.isAtRest = function () {\n      return Math.abs(this._currentState.velocity) < this._restSpeedThreshold && (this.getDisplacementDistanceForState(this._currentState) <= this._displacementFromRestThreshold || 0 === this._springConfig.tension);\n    }, e._interpolate = function (t) {\n      this._currentState.position = this._currentState.position * t + this._previousState.position * (1 - t), this._currentState.velocity = this._currentState.velocity * t + this._previousState.velocity * (1 - t);\n    }, e.addListener = function (t) {\n      return this.listeners.push(t), this;\n    }, e.addOneTimeListener = function (t) {\n      var e = this;\n      return Object.keys(t).forEach(function (i) {\n        var n;\n        t[i] = (n = t[i], function () {\n          n.apply(void 0, [].slice.call(arguments)), e.removeListener(t);\n        });\n      }), this.listeners.push(t), this;\n    }, e.removeListener = function (t) {\n      return S(this.listeners, t), this;\n    }, t;\n  }(),\n  w = /*#__PURE__*/function () {\n    function t(t) {\n      this.looper = t || new E(), this.looper.springSystem = this, this.listeners = [], this._activeSprings = [], this._idleSpringIndices = [], this._isIdle = !0, this._lastTimeMillis = -1, this._springRegistry = {};\n    }\n    var e = t.prototype;\n    return e.createSpring = function (t, e) {\n      return this.createSpringWithConfig({\n        tension: t,\n        friction: e\n      });\n    }, e.createSpringWithConfig = function (t) {\n      var e = new I(this);\n      return this.registerSpring(e), e.setSpringConfig(t), e;\n    }, e.getIsIdle = function () {\n      return this._isIdle;\n    }, e.registerSpring = function (t) {\n      this._springRegistry[t.getId()] = t;\n    }, e.deregisterSpring = function (t) {\n      S(this._activeSprings, t), delete this._springRegistry[t.getId()];\n    }, e.advance = function (t, e) {\n      for (var i = this; this._idleSpringIndices.length > 0;) this._idleSpringIndices.pop();\n      for (this._activeSprings.filter(Boolean).forEach(function (n) {\n        n.systemShouldAdvance() ? n.advance(t / 1e3, e / 1e3) : i._idleSpringIndices.push(i._activeSprings.indexOf(n));\n      }); this._idleSpringIndices.length > 0;) {\n        var n = this._idleSpringIndices.pop();\n        n >= 0 && this._activeSprings.splice(n, 1);\n      }\n    }, e.loop = function (t) {\n      var e;\n      -1 === this._lastTimeMillis && (this._lastTimeMillis = t - 1);\n      var i = t - this._lastTimeMillis;\n      this._lastTimeMillis = t;\n      var n = 0,\n        r = this.listeners.length;\n      for (n = 0; n < r; n++) (e = this.listeners[n]).onBeforeIntegrate && e.onBeforeIntegrate(this);\n      for (this.advance(t, i), 0 === this._activeSprings.length && (this._isIdle = !0, this._lastTimeMillis = -1), n = 0; n < r; n++) (e = this.listeners[n]).onAfterIntegrate && e.onAfterIntegrate(this);\n      this._isIdle || this.looper.run();\n    }, e.activateSpring = function (t) {\n      var e = this._springRegistry[t];\n      -1 === this._activeSprings.indexOf(e) && this._activeSprings.push(e), this.getIsIdle() && (this._isIdle = !1, this.looper.run());\n    }, t;\n  }(),\n  O = new w(),\n  x = function (t) {\n    var e = t.springConfig,\n      i = e.overshootClamping,\n      n = t.getOnUpdateFunc,\n      r = t.onAnimationEnd,\n      s = t.onSpringActivate,\n      a = O.createSpring(e.stiffness, e.damping);\n    a.setOvershootClampingEnabled(!!i);\n    var o = {\n      onSpringActivate: s,\n      onSpringAtRest: function () {\n        a.destroy(), r();\n      },\n      onSpringUpdate: n({\n        spring: a,\n        onAnimationEnd: r\n      })\n    };\n    return a.addListener(o), a;\n  },\n  U = function (t) {\n    var e = x(t);\n    return e.setEndValue(1), e;\n  },\n  V = function (t, e) {\n    if (void 0 === e && (e = {}), t && t.length) {\n      e.reverse && t.reverse();\n      var i,\n        n = \"number\" != typeof (i = e.speed) ? 1.1 : 1 + Math.min(Math.max(5 * i, 0), 5),\n        r = 1 / Math.max(Math.min(t.length, 100), 10),\n        s = t.map(function (t, e) {\n          var i = t.getOnUpdateFunc;\n          return t.getOnUpdateFunc = function (t) {\n            var a = i(t);\n            return function (t) {\n              var i = t.getCurrentValue();\n              (i = i < .01 ? 0 : i > .99 ? 1 : i) >= r && s[e + 1] && s[e + 1](Math.max(Math.min(i * n, 1), 0)), a(t);\n            };\n          }, t;\n        }).map(function (t) {\n          var e = x(t);\n          if (e) return e.setEndValue.bind(e);\n        }).filter(Boolean);\n      s[0] && s[0](1);\n    }\n  },\n  F = function (t) {\n    return [0, 1, 4, 5, 12, 13].map(function (e) {\n      return t[e];\n    });\n  },\n  P = function (t) {\n    return t.top < window.innerHeight && t.bottom > 0 && t.left < window.innerWidth && t.right > 0;\n  };\nfunction D(t) {\n  return JSON.parse(t.dataset.flipConfig || \"{}\");\n}\nvar R = function (t, e) {\n    var i;\n    return a(t, ((i = {})[e[0]] = e[1], i));\n  },\n  T = function (t, e) {\n    return r(e ? document.querySelectorAll(\"[\" + d + '=\"' + e + '\"]') : t.querySelectorAll(\"[\" + c + \"]\"));\n  },\n  M = function (t) {\n    return t.map(function (t) {\n      return [t, t.getBoundingClientRect()];\n    });\n  },\n  k = !0,\n  j = function () {\n    return k = !1;\n  },\n  B = function () {\n    return k = !0;\n  },\n  N = function () {\n    return k;\n  },\n  L = function (n) {\n    var o = n.cachedOrderedFlipIds,\n      p = void 0 === o ? [] : o,\n      f = n.inProgressAnimations,\n      h = void 0 === f ? {} : f,\n      v = n.flippedElementPositionsBeforeUpdate,\n      y = void 0 === v ? {} : v,\n      _ = n.flipCallbacks,\n      S = void 0 === _ ? {} : _,\n      E = n.containerEl,\n      A = n.applyTransformOrigin,\n      C = n.spring,\n      b = n.debug,\n      I = n.portalKey,\n      w = n.staggerConfig,\n      O = void 0 === w ? {} : w,\n      x = n.decisionData,\n      j = void 0 === x ? {} : x,\n      B = n.handleEnterUpdateDelete,\n      N = n.onComplete,\n      L = n.onStart;\n    if (k && !window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches) {\n      var q,\n        X = M(T((q = {\n          element: E,\n          portalKey: I\n        }).element, q.portalKey)).map(function (t) {\n          var e = t[0],\n            i = t[1],\n            n = window.getComputedStyle(e);\n          return [e.dataset.flipId, {\n            element: e,\n            rect: i,\n            opacity: parseFloat(n.opacity),\n            transform: n.transform\n          }];\n        }).reduce(R, {}),\n        Y = function (t) {\n          var e = t.containerEl,\n            i = t.portalKey;\n          return i ? function (t) {\n            return function (e) {\n              return r(document.querySelectorAll(\"[\" + d + '=\"' + t + '\"]' + e));\n            };\n          }(i) : e ? function (t) {\n            var e = Math.random().toFixed(5);\n            return t.dataset.flipperId = e, function (i) {\n              return r(t.querySelectorAll('[data-flipper-id=\"' + e + '\"] ' + i));\n            };\n          }(e) : function () {\n            return [];\n          };\n        }({\n          containerEl: E,\n          portalKey: I\n        }),\n        W = function (t) {\n          return function (e) {\n            return t(\"[\" + c + '=\"' + e + '\"]')[0];\n          };\n        }(Y),\n        K = function (t) {\n          return y[t] && X[t];\n        },\n        H = Object.keys(y).concat(Object.keys(X)).filter(function (t) {\n          return !K(t);\n        }),\n        J = {\n          flipCallbacks: S,\n          getElement: W,\n          flippedElementPositionsBeforeUpdate: y,\n          flippedElementPositionsAfterUpdate: X,\n          inProgressAnimations: h,\n          decisionData: j\n        },\n        z = function (t) {\n          var e,\n            i = t.unflippedIds,\n            n = t.flipCallbacks,\n            r = t.getElement,\n            s = t.flippedElementPositionsBeforeUpdate,\n            a = t.flippedElementPositionsAfterUpdate,\n            o = t.inProgressAnimations,\n            l = t.decisionData,\n            p = i.filter(function (t) {\n              return a[t];\n            }).filter(function (t) {\n              return n[t] && n[t].onAppear;\n            }),\n            c = i.filter(function (t) {\n              return s[t] && n[t] && n[t].onExit;\n            }),\n            u = new Promise(function (t) {\n              e = t;\n            }),\n            d = [],\n            f = 0,\n            h = c.map(function (t, i) {\n              var r = s[t].domDataForExitAnimations,\n                a = r.element,\n                p = r.parent,\n                c = r.childPosition,\n                u = c.top,\n                h = c.left,\n                g = c.width,\n                m = c.height;\n              \"static\" === getComputedStyle(p).position && (p.style.position = \"relative\"), a.style.transform = \"matrix(1, 0, 0, 1, 0, 0)\", a.style.position = \"absolute\", a.style.top = u + \"px\", a.style.left = h + \"px\", a.style.height = m + \"px\", a.style.width = g + \"px\";\n              var v = d.filter(function (t) {\n                return t[0] === p;\n              })[0];\n              v || (v = [p, document.createDocumentFragment()], d.push(v)), v[1].appendChild(a), f += 1;\n              var y = function () {\n                try {\n                  p.removeChild(a);\n                } catch (t) {} finally {\n                  0 == (f -= 1) && e();\n                }\n              };\n              return o[t] = {\n                stop: y\n              }, function () {\n                return n[t].onExit(a, i, y, l);\n              };\n            });\n          return d.forEach(function (t) {\n            t[0].appendChild(t[1]);\n          }), h.length || e(), {\n            hideEnteringElements: function () {\n              p.forEach(function (t) {\n                var e = r(t);\n                e && (e.style.opacity = \"0\");\n              });\n            },\n            animateEnteringElements: function () {\n              p.forEach(function (t, e) {\n                var i = r(t);\n                i && n[t].onAppear(i, e, l);\n              });\n            },\n            animateExitingElements: function () {\n              return h.forEach(function (t) {\n                return t();\n              }), u;\n            }\n          };\n        }(a({}, J, {\n          unflippedIds: H\n        })),\n        G = z.hideEnteringElements,\n        Q = z.animateEnteringElements,\n        Z = z.animateExitingElements,\n        $ = a({}, J, {\n          containerEl: E,\n          flippedIds: p.filter(K),\n          applyTransformOrigin: A,\n          spring: C,\n          debug: b,\n          staggerConfig: O,\n          scopedSelector: Y,\n          onComplete: N\n        });\n      L && L(E, j);\n      var tt = function (n) {\n        var o,\n          p = n.flippedIds,\n          c = n.flipCallbacks,\n          d = n.inProgressAnimations,\n          f = n.flippedElementPositionsBeforeUpdate,\n          h = n.flippedElementPositionsAfterUpdate,\n          v = n.applyTransformOrigin,\n          y = n.spring,\n          _ = n.getElement,\n          S = n.debug,\n          E = n.staggerConfig,\n          A = void 0 === E ? {} : E,\n          C = n.decisionData,\n          b = void 0 === C ? {} : C,\n          I = n.onComplete,\n          w = n.containerEl,\n          O = new Promise(function (t) {\n            o = t;\n          });\n        if (I && O.then(function () {\n          return I(w, b);\n        }), !p.length) return function () {\n          return o([]), O;\n        };\n        var x = [],\n          R = _(p[0]),\n          T = R ? R.ownerDocument.querySelector(\"body\") : document.querySelector(\"body\");\n        s(p);\n        var M = p.map(function (n) {\n          var s = f[n].rect,\n            p = h[n].rect,\n            _ = f[n].opacity,\n            S = h[n].opacity,\n            E = p.width < 1 || p.height < 1,\n            A = h[n].element;\n          if (!P(s) && !P(p)) return !1;\n          if (!A) return !1;\n          var C,\n            I,\n            w,\n            O = D(A),\n            U = (w = (I = void 0 === (C = {\n              flipperSpring: y,\n              flippedSpring: O.spring\n            }) ? {} : C).flippedSpring, a({}, g.noWobble, m(I.flipperSpring), m(w))),\n            V = !0 === O.stagger ? \"default\" : O.stagger,\n            R = {\n              element: A,\n              id: n,\n              stagger: V,\n              springConfig: U\n            };\n          if (c[n] && c[n].shouldFlip && !c[n].shouldFlip(b.previous, b.current)) return !1;\n          var k = Math.abs(s.left - p.left) + Math.abs(s.top - p.top),\n            j = Math.abs(s.width - p.width) + Math.abs(s.height - p.height),\n            B = Math.abs(S - _);\n          if (0 === s.height && 0 === p.height || 0 === s.width && 0 === p.width || k < .5 && j < .5 && B < .01) return !1;\n          var N = t.parse(h[n].transform),\n            L = {\n              matrix: N\n            },\n            q = {\n              matrix: []\n            },\n            X = [N];\n          O.translate && (X.push(t.translateX(s.left - p.left)), X.push(t.translateY(s.top - p.top))), O.scale && (X.push(t.scaleX(Math.max(s.width, 1) / Math.max(p.width, 1))), X.push(t.scaleY(Math.max(s.height, 1) / Math.max(p.height, 1)))), O.opacity && (q.opacity = _, L.opacity = S);\n          var Y = [];\n          if (!c[n] || !c[n].shouldInvert || c[n].shouldInvert(b.previous, b.current)) {\n            var W = function (t, e) {\n              return r(t.querySelectorAll(\"[\" + u + '=\"' + e + '\"]'));\n            }(A, n);\n            Y = W.map(function (t) {\n              return [t, D(t)];\n            });\n          }\n          q.matrix = F(X.reduce(t.multiply)), L.matrix = F(L.matrix);\n          var K,\n            H = function (t) {\n              var i = t.element,\n                n = t.invertedChildren,\n                r = t.body;\n              return function (t) {\n                var s = t.matrix,\n                  a = t.opacity,\n                  o = t.forceMinVals;\n                if (e(a) && (i.style.opacity = a + \"\"), o && (i.style.minHeight = \"1px\", i.style.minWidth = \"1px\"), s) {\n                  var l = function (t) {\n                    return \"matrix(\" + t.join(\", \") + \")\";\n                  }(s);\n                  i.style.transform = l, n && function (t) {\n                    var e = t.matrix,\n                      i = t.body;\n                    t.invertedChildren.forEach(function (t) {\n                      var n = t[0],\n                        r = t[1];\n                      if (i.contains(n)) {\n                        var s = e[0],\n                          a = e[3],\n                          o = e[5],\n                          l = {\n                            translateX: 0,\n                            translateY: 0,\n                            scaleX: 1,\n                            scaleY: 1\n                          },\n                          p = \"\";\n                        r.translate && (l.translateX = -e[4] / s, l.translateY = -o / a, p += \"translate(\" + l.translateX + \"px, \" + l.translateY + \"px)\"), r.scale && (l.scaleX = 1 / s, l.scaleY = 1 / a, p += \" scale(\" + l.scaleX + \", \" + l.scaleY + \")\"), n.style.transform = p;\n                      }\n                    });\n                  }({\n                    invertedChildren: n,\n                    matrix: s,\n                    body: r\n                  });\n                }\n              };\n            }({\n              element: A,\n              invertedChildren: Y,\n              body: T\n            });\n          if (c[n] && c[n].onComplete) {\n            var J = c[n].onComplete;\n            K = function () {\n              return J(A, b);\n            };\n          }\n          var z = e(q.opacity) && e(L.opacity) && q.opacity !== L.opacity,\n            G = !1;\n          return a({}, R, {\n            stagger: V,\n            springConfig: U,\n            getOnUpdateFunc: function (t) {\n              var e = t.spring,\n                i = t.onAnimationEnd;\n              return d[n] = {\n                destroy: e.destroy.bind(e),\n                onAnimationEnd: i\n              }, function (t) {\n                c[n] && c[n].onSpringUpdate && c[n].onSpringUpdate(t.getCurrentValue()), G || (G = !0, c[n] && c[n].onStart && c[n].onStart(A, b));\n                var e = t.getCurrentValue();\n                if (T.contains(A)) {\n                  var i = {\n                    matrix: []\n                  };\n                  i.matrix = q.matrix.map(function (t, i) {\n                    return l(t, L.matrix[i], e);\n                  }), z && (i.opacity = l(q.opacity, L.opacity, e)), H(i);\n                } else t.destroy();\n              };\n            },\n            initializeFlip: function () {\n              H({\n                matrix: q.matrix,\n                opacity: z ? q.opacity : void 0,\n                forceMinVals: E\n              }), c[n] && c[n].onStartImmediate && c[n].onStartImmediate(A, b), O.transformOrigin ? A.style.transformOrigin = O.transformOrigin : v && (A.style.transformOrigin = \"0 0\"), Y.forEach(function (t) {\n                var e = t[0],\n                  i = t[1];\n                i.transformOrigin ? e.style.transformOrigin = i.transformOrigin : v && (e.style.transformOrigin = \"0 0\");\n              });\n            },\n            onAnimationEnd: function (t) {\n              delete d[n], i(K) && K(), A.style.transform = \"\", Y.forEach(function (t) {\n                t[0].style.transform = \"\";\n              }), E && A && (A.style.minHeight = \"\", A.style.minWidth = \"\"), t || (x.push(n), x.length >= M.length && o(x));\n            },\n            delayUntil: O.delayUntil\n          });\n        }).filter(Boolean);\n        if (M.forEach(function (t) {\n          return (0, t.initializeFlip)();\n        }), S) return function () {};\n        var k = M.filter(function (t) {\n            return t.delayUntil && (e = t.delayUntil, M.filter(function (t) {\n              return t.id === e;\n            }).length);\n            var e;\n          }),\n          j = {},\n          B = {},\n          N = {};\n        k.forEach(function (t) {\n          t.stagger ? (N[t.stagger] = !0, B[t.delayUntil] ? B[t.delayUntil].push(t.stagger) : B[t.delayUntil] = [t.stagger]) : j[t.delayUntil] ? j[t.delayUntil].push(t) : j[t.delayUntil] = [t];\n        });\n        var L = M.filter(function (t) {\n            return t.stagger;\n          }).reduce(function (t, e) {\n            return t[e.stagger] ? t[e.stagger].push(e) : t[e.stagger] = [e], t;\n          }, {}),\n          q = M.filter(function (t) {\n            return -1 === k.indexOf(t);\n          });\n        return q.forEach(function (t) {\n          t.onSpringActivate = function () {\n            j[t.id] && j[t.id].forEach(U), B[t.id] && Object.keys(B[t.id].reduce(function (t, e) {\n              var i;\n              return a(t, ((i = {})[e] = !0, i));\n            }, {})).forEach(function (t) {\n              V(L[t], A[t]);\n            });\n          };\n        }), function () {\n          return M.length || o([]), q.filter(function (t) {\n            return !t.stagger;\n          }).forEach(U), Object.keys(L).forEach(function (t) {\n            N[t] || V(L[t], A[t]);\n          }), O;\n        };\n      }($);\n      B ? B({\n        hideEnteringElements: G,\n        animateEnteringElements: Q,\n        animateExitingElements: Z,\n        animateFlippedElements: tt\n      }) : (G(), Z().then(Q), tt());\n    }\n  },\n  q = function (t) {\n    var e = t.element,\n      i = t.flipCallbacks,\n      n = void 0 === i ? {} : i,\n      s = t.inProgressAnimations,\n      o = void 0 === s ? {} : s,\n      l = T(e, t.portalKey),\n      p = r(e.querySelectorAll(\"[\" + u + \"]\")),\n      c = {},\n      d = [],\n      h = {};\n    l.filter(function (t) {\n      return n && n[t.dataset.flipId] && n[t.dataset.flipId].onExit;\n    }).forEach(function (t) {\n      var e = t.parentNode;\n      if (t.closest) {\n        var i = t.closest(\"[\" + f + \"]\");\n        i && (e = i);\n      }\n      var n = d.findIndex(function (t) {\n        return t[0] === e;\n      });\n      -1 === n && (d.push([e, e.getBoundingClientRect()]), n = d.length - 1), c[t.dataset.flipId] = d[n][1], h[t.dataset.flipId] = e;\n    });\n    var g = M(l),\n      m = g.map(function (t) {\n        var e = t[0],\n          i = t[1],\n          r = {};\n        if (n && n[e.dataset.flipId] && n[e.dataset.flipId].onExit) {\n          var s = c[e.dataset.flipId];\n          a(r, {\n            element: e,\n            parent: h[e.dataset.flipId],\n            childPosition: {\n              top: i.top - s.top,\n              left: i.left - s.left,\n              width: i.width,\n              height: i.height\n            }\n          });\n        }\n        return [e.dataset.flipId, {\n          rect: i,\n          opacity: parseFloat(window.getComputedStyle(e).opacity || \"1\"),\n          domDataForExitAnimations: r\n        }];\n      }).reduce(R, {});\n    return function (t, e) {\n      Object.keys(t).forEach(function (e) {\n        t[e].destroy && t[e].destroy(), t[e].onAnimationEnd && t[e].onAnimationEnd(!0), delete t[e];\n      }), e.forEach(function (t) {\n        t.style.transform = \"\", t.style.opacity = \"\";\n      });\n    }(o, l.concat(p)), {\n      flippedElementPositions: m,\n      cachedOrderedFlipIds: g.map(function (t) {\n        return t[0].dataset.flipId;\n      })\n    };\n  },\n  X = /*#__PURE__*/function () {\n    function t(t) {\n      this.element = void 0, this.staggerConfig = void 0, this.applyTransformOrigin = !0, this.handleEnterUpdateDelete = void 0, this.debug = void 0, this.spring = void 0, this.inProgressAnimations = void 0, this.flipCallbacks = void 0, this.snapshot = void 0, this.onComplete = void 0, this.onStart = void 0, a(this, t), this.inProgressAnimations = {}, this.flipCallbacks = {}, this.recordBeforeUpdate = this.recordBeforeUpdate.bind(this), this.update = this.update.bind(this), this.addFlipped = this.addFlipped.bind(this), this.addInverted = this.addInverted.bind(this);\n    }\n    var e = t.prototype;\n    return e.recordBeforeUpdate = function () {\n      this.snapshot = q({\n        element: this.element,\n        flipCallbacks: this.flipCallbacks,\n        inProgressAnimations: this.inProgressAnimations\n      });\n    }, e.update = function (t, e) {\n      this.snapshot && (L({\n        flippedElementPositionsBeforeUpdate: this.snapshot.flippedElementPositions,\n        cachedOrderedFlipIds: this.snapshot.cachedOrderedFlipIds,\n        containerEl: this.element,\n        inProgressAnimations: this.inProgressAnimations,\n        flipCallbacks: this.flipCallbacks,\n        applyTransformOrigin: this.applyTransformOrigin,\n        spring: this.spring,\n        debug: this.debug,\n        staggerConfig: this.staggerConfig,\n        handleEnterUpdateDelete: this.handleEnterUpdateDelete,\n        decisionData: {\n          previous: t,\n          current: e\n        },\n        onComplete: this.onComplete,\n        onStart: this.onStart\n      }), delete this.snapshot);\n    }, e.addFlipped = function (t) {\n      var e = t.element,\n        i = t.flipId,\n        n = t.opacity,\n        r = t.translate,\n        s = t.scale,\n        o = t.transformOrigin,\n        l = t.spring,\n        p = t.stagger,\n        c = t.delayUntil,\n        u = t.onAppear,\n        d = t.onStart,\n        f = t.onSpringUpdate,\n        h = t.onComplete,\n        g = t.onExit,\n        m = t.shouldFlip,\n        v = t.shouldInvert;\n      if (!e) throw new Error(\"no element provided\");\n      if (!i) throw new Error(\"No flipId provided\");\n      var y = {\n        scale: s,\n        translate: r,\n        opacity: n,\n        transformOrigin: o,\n        spring: l,\n        stagger: p,\n        delayUntil: c\n      };\n      y.scale || y.translate || y.opacity || a(y, {\n        translate: !0,\n        scale: !0,\n        opacity: !0\n      }), i && (e.dataset.flipId = String(i)), e.dataset.flipConfig = JSON.stringify(y), this.flipCallbacks[i] = {\n        shouldFlip: m,\n        shouldInvert: v,\n        onAppear: u,\n        onStart: d,\n        onSpringUpdate: f,\n        onComplete: h,\n        onExit: g\n      };\n    }, e.addInverted = function (t) {\n      var e = t.element,\n        i = t.parent,\n        n = t.opacity,\n        r = t.translate,\n        s = t.scale,\n        o = t.transformOrigin;\n      if (!e) throw new Error(\"no element provided\");\n      if (!i) throw new Error(\"parent must be provided\");\n      var l = i.dataset.flipId,\n        p = {\n          scale: s,\n          translate: r,\n          opacity: n,\n          transformOrigin: o\n        };\n      p.scale || p.translate || p.opacity || a(p, {\n        translate: !0,\n        scale: !0,\n        opacity: !0\n      }), e.dataset.inverseFlipId = l, e.dataset.flipConfig = JSON.stringify(p);\n    }, t;\n  }(),\n  Y = new w(),\n  W = function (t) {\n    var e = t.values,\n      i = t.onUpdate,\n      n = t.delay,\n      r = void 0 === n ? 0 : n,\n      s = t.onComplete,\n      o = a({}, g.noWobble, m(t.config)),\n      p = o.overshootClamping,\n      c = Y.createSpring(o.stiffness, o.damping);\n    return c.setOvershootClampingEnabled(!!p), c.addListener({\n      onSpringAtRest: function (t) {\n        s && s(), t.destroy();\n      },\n      onSpringUpdate: function (t) {\n        var n = t.getCurrentValue();\n        if (!e) return i(n);\n        var r = Object.keys(e).map(function (t) {\n          return [t, l(e[t][0], e[t][1], n)];\n        }).reduce(function (t, e) {\n          var i;\n          return Object.assign(t, ((i = {})[e[0]] = e[1], i));\n        }, {});\n        i(r);\n      }\n    }), r ? setTimeout(function () {\n      c.setEndValue(1);\n    }, r) : c.setEndValue(1), c;\n  };\nexport { X as Flipper, h as constants, j as disableFlip, B as enableFlip, q as getFlippedElementPositionsBeforeUpdate, N as isFlipEnabled, L as onFlipKeyUpdate, W as spring, p as utilities };","map":{"version":3,"names":["e","isNumber","t","i","isFunction","n","isObject","Object","prototype","toString","call","r","toArray","Array","slice","apply","s","getDuplicateValsAsStrings","reduce","keys","filter","a","arguments","forEach","hasOwnProperty","o","l","tweenProp","p","__proto__","assign","c","u","d","f","h","DATA_FLIP_ID","DATA_INVERSE_FLIP_ID","DATA_FLIP_COMPONENT_ID","DATA_FLIP_CONFIG","DATA_PORTAL_KEY","DATA_EXIT_CONTAINER","g","noWobble","stiffness","damping","gentle","veryGentle","wobbly","stiff","m","normalizeSpring","indexOf","window","requestAnimationFrame","v","setTimeout","y","Date","now","_","performance","S","splice","E","run","springSystem","loop","A","PhysicsState","position","velocity","C","b","I","_id","_springSystem","listeners","_startValue","_currentState","_displacementFromRestThreshold","_endValue","_overshootClampingEnabled","_previousState","_restSpeedThreshold","_tempState","_timeAccumulator","_wasAtRest","_cachedSpringConfig","getId","destroy","deregisterSpring","setSpringConfig","_springConfig","getCurrentValue","getDisplacementDistanceForState","Math","abs","setEndValue","prevEndValue","isAtRest","activateSpring","length","onSpringEndStateChange","setVelocity","setCurrentValue","onSpringUpdate","setAtRest","setOvershootClampingEnabled","isOvershooting","tension","advance","friction","_interpolate","notifyPositionUpdated","Boolean","onSpringActivate","_onActivateCalled","onSpringAtRest","systemShouldAdvance","wasAtRest","addListener","push","addOneTimeListener","removeListener","w","looper","_activeSprings","_idleSpringIndices","_isIdle","_lastTimeMillis","_springRegistry","createSpring","createSpringWithConfig","registerSpring","getIsIdle","pop","onBeforeIntegrate","onAfterIntegrate","O","x","createSuspendedSpring","springConfig","overshootClamping","getOnUpdateFunc","onAnimationEnd","spring","U","V","createStaggeredSprings","reverse","speed","min","max","map","bind","F","convertMatrix3dArrayTo2dArray","P","rectInViewport","top","innerHeight","bottom","left","innerWidth","right","D","JSON","parse","dataset","flipConfig","R","addTupleToObject","T","getAllElements","document","querySelectorAll","M","getRects","getBoundingClientRect","k","j","disableFlip","B","enableFlip","N","isFlipEnabled","L","onFlipKeyUpdate","cachedOrderedFlipIds","inProgressAnimations","flippedElementPositionsBeforeUpdate","flipCallbacks","containerEl","applyTransformOrigin","debug","portalKey","staggerConfig","decisionData","handleEnterUpdateDelete","onComplete","onStart","matchMedia","matches","q","X","element","getComputedStyle","flipId","rect","opacity","parseFloat","transform","Y","random","toFixed","flipperId","W","K","isFlipped","H","concat","J","getElement","flippedElementPositionsAfterUpdate","z","unflippedIds","onAppear","onExit","Promise","domDataForExitAnimations","parent","childPosition","width","height","style","createDocumentFragment","appendChild","stop","removeChild","hideEnteringElements","animateEnteringElements","animateExitingElements","G","Q","Z","$","flippedIds","scopedSelector","tt","then","ownerDocument","querySelector","flipperSpring","flippedSpring","stagger","id","shouldFlip","previous","current","matrix","translate","translateX","translateY","scale","scaleX","scaleY","shouldInvert","multiply","invertedChildren","body","forceMinVals","minHeight","minWidth","join","contains","initializeFlip","onStartImmediate","transformOrigin","delayUntil","animateFlippedElements","getFlippedElementPositionsBeforeUpdate","parentNode","closest","findIndex","flippedElementPositions","snapshot","recordBeforeUpdate","update","addFlipped","addInverted","Error","String","stringify","inverseFlipId","createSimpleSpring","values","onUpdate","delay","config","Flipper","constants","utilities"],"sources":["../src/utilities/index.ts","../src/forked-rebound/onFrame.js","../src/constants.ts","../src/springSettings/index.ts","../src/forked-rebound/util.js","../src/forked-rebound/Loopers.js","../src/forked-rebound/Spring.js","../src/forked-rebound/SpringSystem.js","../src/flip/animateFlippedElements/spring/index.ts","../src/flip/animateFlippedElements/index.ts","../src/flip/getFlippedElementPositions/utilities.ts","../src/flip/index.ts","../src/flip/getFlippedElementPositions/getFlippedElementPositionsAfterUpdate/index.ts","../src/flip/animateUnflippedElements/index.ts","../src/flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/index.ts","../src/Flipper.ts","../src/Spring/index.ts"],"sourcesContent":["import { IndexableObject } from './types'\n\nexport const isNumber = (x: any) => typeof x === 'number'\n\nexport const isFunction = (x: any) => typeof x === 'function'\n\nexport const isObject = (x: any) =>\n  Object.prototype.toString.call(x) === '[object Object]'\n\nexport const toArray = (arrayLike: ArrayLike<any>) =>\n  Array.prototype.slice.apply(arrayLike)\n\nexport const getDuplicateValsAsStrings = (arr: string[]): string[] => {\n  const baseObj: IndexableObject = {}\n  const obj = arr.reduce((acc, curr) => {\n    acc[curr] = (acc[curr] || 0) + 1\n    return acc\n  }, baseObj)\n  return Object.keys(obj).filter(val => obj[val] > 1)\n}\n\n// tslint only likes this with a regular function, not an arrow function\nexport function assign(target: IndexableObject, ...args: IndexableObject[]) {\n  args.forEach(arg => {\n    if (!arg) {\n      return\n    }\n    // Skip over if undefined or null\n    for (const nextKey in arg) {\n      // Avoid bugs when hasOwnProperty is shadowed\n      if (Object.prototype.hasOwnProperty.call(arg, nextKey)) {\n        target[nextKey] = arg[nextKey]\n      }\n    }\n  })\n  return target\n}\n\nexport const tweenProp = (start: number, end: number, position: number) =>\n  start + (end - start) * position\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nlet _onFrame\nif (typeof window !== \"undefined\") {\n  _onFrame = window.requestAnimationFrame\n}\n\n_onFrame =\n  _onFrame ||\n  function(callback) {\n    window.setTimeout(callback, 1000 / 60)\n  }\n\nexport default _onFrame\n","export const DATA_FLIP_ID = 'data-flip-id'\nexport const DATA_INVERSE_FLIP_ID = 'data-inverse-flip-id'\nexport const DATA_FLIP_COMPONENT_ID = 'data-flip-component-id'\nexport const DATA_FLIP_CONFIG = 'data-flip-config'\nexport const DATA_PORTAL_KEY = 'data-portal-key'\nexport const DATA_EXIT_CONTAINER = 'data-exit-container'\n","import { isObject, assign } from '../utilities'\nimport { SpringPresets, SpringConfig, SpringOption } from './types'\n\n// adapted from\n// https://github.com/chenglou/react-motion/blob/master/src/presets.js\nexport const springPresets: SpringPresets = {\n  noWobble: { stiffness: 200, damping: 26 },\n  gentle: { stiffness: 120, damping: 14 },\n  veryGentle: { stiffness: 130, damping: 17 },\n  wobbly: { stiffness: 180, damping: 12 },\n  stiff: { stiffness: 260, damping: 26 }\n}\n\nfunction argIsSpringConfig(\n  arg: SpringConfig | keyof SpringPresets | undefined\n): arg is SpringConfig {\n  return isObject(arg)\n}\n\nexport const normalizeSpring = (\n  spring?: SpringConfig | keyof SpringPresets | any\n) => {\n  if (argIsSpringConfig(spring)) {\n    return spring\n  } else if (Object.keys(springPresets).indexOf(spring) > -1) {\n    return springPresets[spring]\n  } else {\n    return {}\n  }\n}\n\nexport const getSpringConfig = ({\n  flipperSpring,\n  flippedSpring\n}: { flipperSpring?: SpringOption; flippedSpring?: SpringOption } = {}) => {\n  return assign(\n    {},\n    springPresets.noWobble,\n    normalizeSpring(flipperSpring),\n    normalizeSpring(flippedSpring)\n  )\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nexport { default as onFrame } from './onFrame'\n\nconst start = Date.now()\nexport const performanceNow =\n  typeof performance === 'object' && typeof performance.now === 'function'\n    ? () => performance.now()\n    : () => Date.now() - start\n\n// Lop off the first occurence of the reference in the Array.\nexport function removeFirst(array, item) {\n  const idx = array.indexOf(item)\n  idx !== -1 && array.splice(idx, 1)\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nimport { onFrame, performanceNow } from \"./util\"\n\n/**\n * Plays each frame of the SpringSystem on animation\n * timing loop. This is the default type of looper for a new spring system\n * as it is the most common when developing UI.\n * @public\n */\nexport class AnimationLooper {\n  run() {\n    onFrame(() => {\n      this.springSystem.loop(performanceNow())\n    })\n  }\n}\n","/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n *\n */\n\nimport { removeFirst } from './util'\n\nclass PhysicsState {\n  constructor() {\n    this.position = 0\n    this.velocity = 0\n  }\n}\n\nlet ID = 0\nconst MAX_DELTA_TIME_SEC = 0.064\nconst SOLVER_TIMESTEP_SEC = 0.001\n\n/**\n * Provides a model of a classical spring acting to\n * resolve a body to equilibrium. Springs have configurable\n * tension which is a force multipler on the displacement of the\n * spring from its rest point or `endValue` as defined by [Hooke's\n * law](http://en.wikipedia.org/wiki/Hooke's_law). Springs also have\n * configurable friction, which ensures that they do not oscillate\n * infinitely. When a Spring is displaced by updating it's resting\n * or `currentValue`, the SpringSystems that contain that Spring\n * will automatically start looping to solve for equilibrium. As each\n * timestep passes, `SpringListener` objects attached to the Spring\n * will be notified of the updates providing a way to drive an\n * animation off of the spring's resolution curve.\n * @public\n */\nclass Spring {\n  constructor(springSystem) {\n    this._id = `s${ID++}`\n    this._springSystem = springSystem\n\n    this.listeners = []\n    this._startValue = 0\n\n    this._currentState = new PhysicsState()\n    this._displacementFromRestThreshold = 0.001\n    this._endValue = 0\n    this._overshootClampingEnabled = false\n    this._previousState = new PhysicsState()\n    this._restSpeedThreshold = 0.001\n\n    this._tempState = new PhysicsState()\n    this._timeAccumulator = 0\n    this._wasAtRest = true\n    // hack from alex -- only call 1x\n    this._onActivateCalled\n    this._cachedSpringConfig = {}\n  }\n\n  getId() {\n    return this._id\n  }\n\n  /**\n   * Remove a Spring from simulation and clear its listeners.\n   * @public\n   */\n  destroy() {\n    this.listeners = []\n    this._springSystem.deregisterSpring(this)\n  }\n\n  /**\n   * Set the configuration values for this Spring. A SpringConfig\n   * contains the tension and friction values used to solve for the\n   * equilibrium of the Spring in the physics loop.\n   * @public\n   */\n  setSpringConfig(springConfig) {\n    this._springConfig = springConfig\n    return this\n  }\n  /**\n   * Retrieve the current value of the Spring.\n   * @public\n   */\n  getCurrentValue() {\n    return this._currentState.position\n  }\n\n  /**\n   * Get the absolute distance of the Spring from a given state value\n   */\n  getDisplacementDistanceForState(state) {\n    return Math.abs(this._endValue - state.position)\n  }\n\n  /**\n   * Set the endValue or resting position of the spring. If this\n   * value is different than the current value, the SpringSystem will\n   * be notified and will begin running its solver loop to resolve\n   * the Spring to equilibrium. Any listeners that are registered\n   * for onSpringEndStateChange will also be notified of this update\n   * immediately.\n   * @public\n   */\n\n  setEndValue(endValue) {\n    if (endValue === this._endValue) return this\n    this.prevEndValue = endValue\n    if (this._endValue === endValue && this.isAtRest()) {\n      return this\n    }\n    this._startValue = this.getCurrentValue()\n    this._endValue = endValue\n    this._springSystem.activateSpring(this.getId())\n    for (let i = 0, len = this.listeners.length; i < len; i++) {\n      const listener = this.listeners[i]\n      const onChange = listener.onSpringEndStateChange\n      onChange && onChange(this)\n    }\n    return this\n  }\n\n  /**\n   * Set the current velocity of the Spring, in pixels per second. As\n   * previously mentioned, this can be useful when you are performing\n   * a direct manipulation gesture. When a UI element is released you\n   * may call setVelocity on its animation Spring so that the Spring\n   * continues with the same velocity as the gesture ended with. The\n   * friction, tension, and displacement of the Spring will then\n   * govern its motion to return to rest on a natural feeling curve.\n   * @public\n   */\n  setVelocity(velocity) {\n    if (velocity === this._currentState.velocity) {\n      return this\n    }\n    this._currentState.velocity = velocity\n    this._springSystem.activateSpring(this.getId())\n    return this\n  }\n\n  setCurrentValue(currentValue) {\n    this._startValue = currentValue\n    this._currentState.position = currentValue\n    for (var i = 0, len = this.listeners.length; i < len; i++) {\n      var listener = this.listeners[i]\n      listener.onSpringUpdate && listener.onSpringUpdate(this)\n    }\n    return this\n  }\n\n  setAtRest() {\n    this._endValue = this._currentState.position\n    this._tempState.position = this._currentState.position\n    this._currentState.velocity = 0\n    return this\n  }\n\n  /**\n   * Enable overshoot clamping. This means that the Spring will stop\n   * immediately when it reaches its resting position regardless of\n   * any existing momentum it may have. This can be useful for certain\n   * types of animations that should not oscillate such as a scale\n   * down to 0 or alpha fade.\n   * @public\n   */\n  setOvershootClampingEnabled(enabled) {\n    this._overshootClampingEnabled = enabled\n    return this\n  }\n\n  /**\n   * Check if the Spring has gone past its end point by comparing\n   * the direction it was moving in when it started to the current\n   * position and end value.\n   * @public\n   */\n  isOvershooting() {\n    const start = this._startValue\n    const end = this._endValue\n    return (\n      this._springConfig.tension > 0 &&\n      ((start < end && this.getCurrentValue() > end) ||\n        (start > end && this.getCurrentValue() < end))\n    )\n  }\n\n  /**\n   * The main solver method for the Spring. It takes\n   * the current time and delta since the last time step and performs\n   * an RK4 integration to get the new position and velocity state\n   * for the Spring based on the tension, friction, velocity, and\n   * displacement of the Spring.\n   * @public\n   */\n  advance(time, realDeltaTime) {\n    let isAtRest = this.isAtRest()\n\n    if (isAtRest && this._wasAtRest) {\n      return\n    }\n\n    let adjustedDeltaTime = realDeltaTime\n    if (realDeltaTime > MAX_DELTA_TIME_SEC) {\n      adjustedDeltaTime = MAX_DELTA_TIME_SEC\n    }\n\n    this._timeAccumulator += adjustedDeltaTime\n\n    const tension = this._springConfig.tension\n    const friction = this._springConfig.friction\n    let position = this._currentState.position\n    let velocity = this._currentState.velocity\n    let tempPosition = this._tempState.position\n    let tempVelocity = this._tempState.velocity\n    let aVelocity\n    let aAcceleration\n    let bVelocity\n    let bAcceleration\n    let cVelocity\n    let cAcceleration\n    let dVelocity\n    let dAcceleration\n    let dxdt\n    let dvdt\n\n    while (this._timeAccumulator >= SOLVER_TIMESTEP_SEC) {\n      this._timeAccumulator -= SOLVER_TIMESTEP_SEC\n\n      if (this._timeAccumulator < SOLVER_TIMESTEP_SEC) {\n        this._previousState.position = position\n        this._previousState.velocity = velocity\n      }\n\n      aVelocity = velocity\n      aAcceleration =\n        tension * (this._endValue - tempPosition) - friction * velocity\n\n      tempPosition = position + aVelocity * SOLVER_TIMESTEP_SEC * 0.5\n      tempVelocity = velocity + aAcceleration * SOLVER_TIMESTEP_SEC * 0.5\n      bVelocity = tempVelocity\n      bAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      tempPosition = position + bVelocity * SOLVER_TIMESTEP_SEC * 0.5\n      tempVelocity = velocity + bAcceleration * SOLVER_TIMESTEP_SEC * 0.5\n      cVelocity = tempVelocity\n      cAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      tempPosition = position + cVelocity * SOLVER_TIMESTEP_SEC\n      tempVelocity = velocity + cAcceleration * SOLVER_TIMESTEP_SEC\n      dVelocity = tempVelocity\n      dAcceleration =\n        tension * (this._endValue - tempPosition) - friction * tempVelocity\n\n      dxdt =\n        (1.0 / 6.0) * (aVelocity + 2.0 * (bVelocity + cVelocity) + dVelocity)\n      dvdt =\n        (1.0 / 6.0) *\n        (aAcceleration + 2.0 * (bAcceleration + cAcceleration) + dAcceleration)\n\n      position += dxdt * SOLVER_TIMESTEP_SEC\n      velocity += dvdt * SOLVER_TIMESTEP_SEC\n    }\n\n    this._tempState.position = tempPosition\n    this._tempState.velocity = tempVelocity\n\n    this._currentState.position = position\n    this._currentState.velocity = velocity\n\n    if (this._timeAccumulator > 0) {\n      this._interpolate(this._timeAccumulator / SOLVER_TIMESTEP_SEC)\n    }\n\n    if (\n      this.isAtRest() ||\n      (this._overshootClampingEnabled && this.isOvershooting())\n    ) {\n      if (this._springConfig.tension > 0) {\n        this._startValue = this._endValue\n        this._currentState.position = this._endValue\n      } else {\n        this._endValue = this._currentState.position\n        this._startValue = this._endValue\n      }\n      this.setVelocity(0)\n      isAtRest = true\n    }\n\n    let notifyActivate = false\n    if (this._wasAtRest) {\n      this._wasAtRest = false\n      notifyActivate = true\n    }\n\n    let notifyAtRest = false\n    if (isAtRest) {\n      this._wasAtRest = true\n      notifyAtRest = true\n    }\n\n    this.notifyPositionUpdated(notifyActivate, notifyAtRest)\n  }\n\n  notifyPositionUpdated(notifyActivate, notifyAtRest) {\n    this.listeners.filter(Boolean).forEach(listener => {\n      if (\n        notifyActivate &&\n        listener.onSpringActivate &&\n        !this._onActivateCalled\n      ) {\n        listener.onSpringActivate(this)\n        this._onActivateCalled = true\n      }\n\n      if (listener.onSpringUpdate) {\n        listener.onSpringUpdate(this)\n      }\n\n      if (notifyAtRest && listener.onSpringAtRest) {\n        listener.onSpringAtRest(this)\n      }\n    })\n  }\n\n  /**\n   * Check if the SpringSystem should advance. Springs are advanced\n   * a final frame after they reach equilibrium to ensure that the\n   * currentValue is exactly the requested endValue regardless of the\n   * displacement threshold.\n   * @public\n   */\n  systemShouldAdvance() {\n    return !this.isAtRest() || !this.wasAtRest()\n  }\n\n  wasAtRest() {\n    return this._wasAtRest\n  }\n\n  /**\n   * Check if the Spring is atRest meaning that it's currentValue and\n   * endValue are the same and that it has no velocity. The previously\n   * described thresholds for speed and displacement define the bounds\n   * of this equivalence check. If the Spring has 0 tension, then it will\n   * be considered at rest whenever its absolute velocity drops below the\n   * restSpeedThreshold.\n   * @public\n   */\n  isAtRest() {\n    const isAtRest =\n      Math.abs(this._currentState.velocity) < this._restSpeedThreshold &&\n      (this.getDisplacementDistanceForState(this._currentState) <=\n        this._displacementFromRestThreshold ||\n        this._springConfig.tension === 0)\n    return isAtRest\n  }\n\n  _interpolate(alpha) {\n    this._currentState.position =\n      this._currentState.position * alpha +\n      this._previousState.position * (1 - alpha)\n    this._currentState.velocity =\n      this._currentState.velocity * alpha +\n      this._previousState.velocity * (1 - alpha)\n  }\n\n  addListener(newListener) {\n    this.listeners.push(newListener)\n    return this\n  }\n\n  addOneTimeListener(newListener) {\n    const oneTimeFunc = func => (...args) => {\n      func(...args)\n      this.removeListener(newListener)\n    }\n    Object.keys(newListener).forEach(key => {\n      newListener[key] = oneTimeFunc(newListener[key])\n    })\n    this.listeners.push(newListener)\n    return this\n  }\n\n  removeListener(listenerToRemove) {\n    removeFirst(this.listeners, listenerToRemove)\n    return this\n  }\n}\n\nexport default Spring\n","//\n/**\n *  Copyright (c) 2013, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n *\n */\n\nimport { AnimationLooper } from './Loopers'\nimport Spring from './Spring'\nimport { removeFirst } from './util'\n\n/**\n * A set of Springs that all run on the same physics\n * timing loop. To get started with a Rebound animation, first\n * create a new SpringSystem and then add springs to it.\n * @public\n */\nclass SpringSystem {\n  constructor(looper) {\n    this.looper = looper || new AnimationLooper()\n    this.looper.springSystem = this\n\n    this.listeners = []\n    this._activeSprings = []\n    this._idleSpringIndices = []\n    this._isIdle = true\n    this._lastTimeMillis = -1\n    this._springRegistry = {}\n  }\n\n  /**\n   * Add a new spring to this SpringSystem. This Spring will now be solved for\n   * during the physics iteration loop. By default the spring will use the\n   * default Origami spring config with 40 tension and 7 friction, but you can\n   * also provide your own values here.\n   * @public\n   */\n  createSpring(tension, friction) {\n    return this.createSpringWithConfig({ tension, friction })\n  }\n  /**\n   * Add a spring with the provided SpringConfig.\n   * @public\n   */\n  createSpringWithConfig(springConfig) {\n    const spring = new Spring(this)\n    this.registerSpring(spring)\n    spring.setSpringConfig(springConfig)\n    return spring\n  }\n\n  /**\n   * Check if a SpringSystem is idle or active. If all of the Springs in the\n   * SpringSystem are at rest, i.e. the physics forces have reached equilibrium,\n   * then this method will return true.\n   * @public\n   */\n  getIsIdle() {\n    return this._isIdle\n  }\n\n  /**\n   * Manually add a spring to this system. This is called automatically\n   * if a Spring is created with SpringSystem#createSpring.\n   *\n   * This method sets the spring up in the registry so that it can be solved\n   * in the solver loop.\n   * @public\n   */\n  registerSpring(spring) {\n    this._springRegistry[spring.getId()] = spring\n  }\n\n  /**\n   * Deregister a spring with this SpringSystem. The SpringSystem will\n   * no longer consider this Spring during its integration loop once\n   * this is called. This is normally done automatically for you when\n   * you call Spring#destroy.\n   * @public\n   */\n  deregisterSpring(spring) {\n    removeFirst(this._activeSprings, spring)\n    delete this._springRegistry[spring.getId()]\n  }\n\n  advance(time, deltaTime) {\n    while (this._idleSpringIndices.length > 0) {\n      this._idleSpringIndices.pop()\n    }\n    this._activeSprings.filter(Boolean).forEach(spring => {\n      if (spring.systemShouldAdvance()) {\n        spring.advance(time / 1000.0, deltaTime / 1000.0)\n      } else {\n        this._idleSpringIndices.push(this._activeSprings.indexOf(spring))\n      }\n    })\n\n    while (this._idleSpringIndices.length > 0) {\n      const idx = this._idleSpringIndices.pop()\n      idx >= 0 && this._activeSprings.splice(idx, 1)\n    }\n  }\n\n  /**\n   * This is the main solver loop called to move the simulation\n   * forward through time. Before each pass in the solver loop\n   * onBeforeIntegrate is called on an any listeners that have\n   * registered themeselves with the SpringSystem. This gives you\n   * an opportunity to apply any constraints or adjustments to\n   * the springs that should be enforced before each iteration\n   * loop. Next the advance method is called to move each Spring in\n   * the systemShouldAdvance forward to the current time. After the\n   * integration step runs in advance, onAfterIntegrate is called\n   * on any listeners that have registered themselves with the\n   * SpringSystem. This gives you an opportunity to run any post\n   * integration constraints or adjustments on the Springs in the\n   * SpringSystem.\n   * @public\n   */\n  loop(currentTimeMillis) {\n    let listener\n    if (this._lastTimeMillis === -1) {\n      this._lastTimeMillis = currentTimeMillis - 1\n    }\n    const ellapsedMillis = currentTimeMillis - this._lastTimeMillis\n    this._lastTimeMillis = currentTimeMillis\n\n    let i = 0\n    const len = this.listeners.length\n    for (i = 0; i < len; i++) {\n      listener = this.listeners[i]\n      listener.onBeforeIntegrate && listener.onBeforeIntegrate(this)\n    }\n\n    this.advance(currentTimeMillis, ellapsedMillis)\n    if (this._activeSprings.length === 0) {\n      this._isIdle = true\n      this._lastTimeMillis = -1\n    }\n\n    for (i = 0; i < len; i++) {\n      listener = this.listeners[i]\n      listener.onAfterIntegrate && listener.onAfterIntegrate(this)\n    }\n\n    if (!this._isIdle) {\n      this.looper.run()\n    }\n  }\n\n  /**\n   * Used to notify the SpringSystem that a Spring has become displaced.\n   * The system responds by starting its solver loop up if it is currently idle.\n   */\n  activateSpring(springId) {\n    const spring = this._springRegistry[springId]\n    if (this._activeSprings.indexOf(spring) === -1) {\n      this._activeSprings.push(spring)\n    }\n    if (this.getIsIdle()) {\n      this._isIdle = false\n      this.looper.run()\n    }\n  }\n}\n\nexport default SpringSystem\n","import { SpringSystem } from '../../../forked-rebound'\nimport { StaggerConfigValue } from '../../../types'\nimport { FlipData, FlipDataArray } from '../types'\nimport {\n  SpringSystemInterface,\n  AddListenerArgs\n} from '../../../forked-rebound/types'\n\n// this should get created only 1x\nconst springSystem: SpringSystemInterface = new SpringSystem()\n\nexport const createSuspendedSpring = (flipData: FlipData) => {\n  const {\n    springConfig: { stiffness, damping, overshootClamping },\n    getOnUpdateFunc,\n    onAnimationEnd,\n    onSpringActivate\n  } = flipData\n\n  const spring = springSystem.createSpring(stiffness!, damping!)\n  spring.setOvershootClampingEnabled(!!overshootClamping)\n  const onSpringAtRest = () => {\n    // prevent SpringSystem from caching unused springs\n    spring.destroy()\n    onAnimationEnd()\n  }\n\n  const springConfig: AddListenerArgs = {\n    onSpringActivate,\n    onSpringAtRest,\n    onSpringUpdate: getOnUpdateFunc({\n      spring,\n      onAnimationEnd\n    })\n  }\n\n  spring.addListener(springConfig)\n  return spring\n}\n\nexport const createSpring = (flipped: FlipData) => {\n  const spring = createSuspendedSpring(flipped)\n  spring.setEndValue(1)\n  return spring\n}\n\nexport const normalizeSpeed = (speedConfig: number | undefined) => {\n  if (typeof speedConfig !== 'number') return 1.1\n  return 1 + Math.min(Math.max(speedConfig * 5, 0), 5)\n}\n\nexport const createStaggeredSprings = (\n  flippedArray: FlipDataArray,\n  staggerConfig: StaggerConfigValue = {}\n) => {\n  if (!flippedArray || !flippedArray.length) {\n    return\n  }\n\n  if (staggerConfig.reverse) {\n    flippedArray.reverse()\n  }\n\n  const normalizedSpeed = normalizeSpeed(staggerConfig.speed)\n\n  const nextThreshold = 1 / Math.max(Math.min(flippedArray.length, 100), 10)\n\n  const setEndValueFuncs = flippedArray\n    .map((flipped, i) => {\n      const cachedGetOnUpdate = flipped.getOnUpdateFunc\n\n      // modify the update function to adjust\n      // the end value of the trailing Flipped component\n      flipped.getOnUpdateFunc = args => {\n        const onUpdate = cachedGetOnUpdate(args)\n        return spring => {\n          let currentValue = spring.getCurrentValue()\n          // make sure trailing animations complete\n          currentValue =\n            currentValue < 0.01 ? 0 : currentValue > 0.99 ? 1 : currentValue\n\n          const updateTrailingAnimation = currentValue >= nextThreshold\n          if (updateTrailingAnimation) {\n            if (setEndValueFuncs[i + 1]) {\n              setEndValueFuncs[i + 1]!(\n                Math.max(Math.min(currentValue * normalizedSpeed, 1), 0)\n              )\n            }\n          }\n          // now call the actual update function\n          onUpdate(spring)\n        }\n      }\n      return flipped\n    })\n    .map(flipped => {\n      const spring = createSuspendedSpring(flipped)\n      if (!spring) {\n        return\n      }\n      return spring.setEndValue.bind(spring)\n    })\n    .filter(Boolean)\n\n  if (setEndValueFuncs[0]) {\n    setEndValueFuncs[0]!(1)\n  }\n}\n","import * as Rematrix from 'rematrix'\nimport { getSpringConfig } from '../../springSettings'\nimport {\n  toArray,\n  isFunction,\n  isNumber,\n  getDuplicateValsAsStrings,\n  assign,\n  tweenProp\n} from '../../utilities'\nimport * as constants from '../../constants'\nimport {\n  GetOnUpdateFunc,\n  OnUpdate,\n  Matrix,\n  InvertedChildren,\n  AnimateFlippedElementsArgs,\n  AnimatedVals,\n  FlipDataArray,\n  FlipData,\n  InitializeFlip\n} from './types'\nimport { BoundingClientRect } from '../getFlippedElementPositions/types'\nimport { FlippedIds } from '../types'\nimport { createSpring, createStaggeredSprings } from './spring'\nimport { IndexableObject } from '../../utilities/types'\nimport { FlipId } from '../../types'\n\n// 3d transforms were causing weird issues in chrome,\n// especially when opacity was also being tweened,\n// so convert to a 2d matrix\nexport const convertMatrix3dArrayTo2dArray = (matrix: Matrix): Matrix =>\n  [0, 1, 4, 5, 12, 13].map(index => matrix[index])\n\nexport const convertMatrix2dArrayToString = (matrix: Matrix) =>\n  `matrix(${matrix.join(', ')})`\n\nexport const invertTransformsForChildren = ({\n  invertedChildren,\n  matrix,\n  body\n}: {\n  matrix: Matrix\n  body: HTMLBodyElement\n  invertedChildren: InvertedChildren\n}) => {\n  invertedChildren.forEach(([child, childFlipConfig]) => {\n    if (!body.contains(child)) {\n      return\n    }\n    const scaleX = matrix[0]\n    const scaleY = matrix[3]\n    const translateX = matrix[4]\n    const translateY = matrix[5]\n\n    const inverseVals = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 }\n    let transformString = ''\n    if (childFlipConfig.translate) {\n      inverseVals.translateX = -translateX / scaleX\n      inverseVals.translateY = -translateY / scaleY\n      transformString += `translate(${inverseVals.translateX}px, ${inverseVals.translateY}px)`\n    }\n    if (childFlipConfig.scale) {\n      inverseVals.scaleX = 1 / scaleX\n      inverseVals.scaleY = 1 / scaleY\n      transformString += ` scale(${inverseVals.scaleX}, ${inverseVals.scaleY})`\n    }\n    child.style.transform = transformString\n  })\n}\n\nexport const createApplyStylesFunc =\n  ({\n    element,\n    invertedChildren,\n    body\n  }: {\n    element: HTMLElement\n    invertedChildren: InvertedChildren\n    body: HTMLBodyElement\n  }) =>\n  ({\n    matrix,\n    opacity,\n    forceMinVals\n  }: {\n    matrix: Matrix\n    opacity?: number\n    forceMinVals?: boolean\n  }) => {\n    if (isNumber(opacity)) {\n      element.style.opacity = opacity + ''\n    }\n\n    if (forceMinVals) {\n      element.style.minHeight = '1px'\n      element.style.minWidth = '1px'\n    }\n\n    if (!matrix) {\n      return\n    }\n\n    const stringTransform = convertMatrix2dArrayToString(matrix)\n\n    // always apply transform, even if identity,\n    // because identity might be the starting state in a FLIP\n    // transition, if the element's position is controlled by transforms\n    element.style.transform = stringTransform\n\n    if (invertedChildren) {\n      invertTransformsForChildren({\n        invertedChildren,\n        matrix,\n        body\n      })\n    }\n  }\n\nexport const rectInViewport = ({\n  top,\n  bottom,\n  left,\n  right\n}: BoundingClientRect) => {\n  return (\n    top < window.innerHeight &&\n    bottom > 0 &&\n    left < window.innerWidth &&\n    right > 0\n  )\n}\n\nconst getInvertedChildren = (element: HTMLElement, id: string) =>\n  toArray(\n    element.querySelectorAll(`[${constants.DATA_INVERSE_FLIP_ID}=\"${id}\"]`)\n  )\n\nfunction extractFlipConfig(element: HTMLElement) {\n  const flipConfig = JSON.parse(element.dataset.flipConfig || '{}')\n  return flipConfig\n}\n\nexport default ({\n  flippedIds,\n  flipCallbacks,\n  inProgressAnimations,\n  flippedElementPositionsBeforeUpdate,\n  flippedElementPositionsAfterUpdate,\n  applyTransformOrigin,\n  spring,\n  getElement,\n  debug,\n  staggerConfig = {},\n  decisionData = {},\n  onComplete,\n  containerEl\n}: AnimateFlippedElementsArgs) => {\n  // the stuff below is used so we can return a promise that resolves when all FLIP animations have\n  // completed\n  let closureResolve: (flipIds: FlippedIds) => void\n\n  const flipCompletedPromise: Promise<FlippedIds> = new Promise(resolve => {\n    closureResolve = resolve\n  })\n  // hook for users of lib to attach logic when all flip animations have completed\n  if (onComplete) {\n    flipCompletedPromise.then(() => onComplete(containerEl, decisionData))\n  }\n  if (!flippedIds.length) {\n    return () => {\n      closureResolve!([])\n      return flipCompletedPromise\n    }\n  }\n\n  const completedAnimationIds: FlippedIds = []\n\n  const firstElement: HTMLElement = getElement(flippedIds[0])\n  // special handling for iframes\n  const body = firstElement\n    ? firstElement.ownerDocument!.querySelector('body')!\n    : document.querySelector('body')!\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (debug) {\n      // eslint-disable-next-line no-console\n      console.error(\n        '[react-flip-toolkit]\\nThe \"debug\" prop is set to true. All FLIP animations will return at the beginning of the transition.'\n      )\n    }\n  }\n\n  const duplicateFlipIds = getDuplicateValsAsStrings(flippedIds)\n  if (process.env.NODE_ENV !== 'production') {\n    if (duplicateFlipIds.length) {\n      // eslint-disable-next-line no-console\n      console.error(\n        `[react-flip-toolkit]\\nThere are currently multiple elements with the same flipId on the page.\\nThe animation will only work if each Flipped component has a unique flipId.\\nDuplicate flipId${\n          duplicateFlipIds.length > 1 ? 's' : ''\n        }: ${duplicateFlipIds.join('\\n')}`\n      )\n    }\n  }\n\n  const flipDataArray: FlipDataArray = flippedIds\n\n    // take all the measurements we need\n    // and return an object with animation functions + necessary data\n    .map(id => {\n      const prevRect = flippedElementPositionsBeforeUpdate[id].rect\n      const currentRect = flippedElementPositionsAfterUpdate[id].rect\n      const prevOpacity = flippedElementPositionsBeforeUpdate[id].opacity\n      const currentOpacity = flippedElementPositionsAfterUpdate[id].opacity\n      const needsForcedMinVals = currentRect.width < 1 || currentRect.height < 1\n      const element = flippedElementPositionsAfterUpdate[id].element\n\n      // don't animate elements outside of the user's viewport\n      if (!rectInViewport(prevRect) && !rectInViewport(currentRect)) {\n        return false\n      }\n\n      // this might happen if we are rapidly adding & removing elements(?)\n      if (!element) {\n        return false\n      }\n\n      const flipConfig = extractFlipConfig(element)\n\n      const springConfig = getSpringConfig({\n        flipperSpring: spring,\n        flippedSpring: flipConfig.spring\n      })\n\n      const stagger =\n        flipConfig.stagger === true ? 'default' : flipConfig.stagger\n\n      const toReturn = {\n        element,\n        id,\n        stagger,\n        springConfig\n      }\n\n      if (flipCallbacks[id] && flipCallbacks[id].shouldFlip) {\n        const elementShouldFlip = flipCallbacks[id].shouldFlip!(\n          decisionData.previous,\n          decisionData.current\n        )\n        if (!elementShouldFlip) {\n          return false\n        }\n      }\n\n      // don't animate elements that didn't visibly change\n      // but possibly animate their children\n\n      const translateXDifference = Math.abs(prevRect.left - currentRect.left)\n      const translateYDifference = Math.abs(prevRect.top - currentRect.top)\n\n      const translateDifference = translateXDifference + translateYDifference\n\n      const scaleXDifference = Math.abs(prevRect.width - currentRect.width)\n      const scaleYDifference = Math.abs(prevRect.height - currentRect.height)\n\n      const scaleDifference = scaleXDifference + scaleYDifference\n\n      const opacityDifference = Math.abs(currentOpacity - prevOpacity)\n      const differenceTooSmall =\n        translateDifference < 0.5 &&\n        scaleDifference < 0.5 &&\n        opacityDifference < 0.01\n\n      const hiddenDueToDimensions =\n        (prevRect.height === 0 && currentRect.height === 0) ||\n        (prevRect.width === 0 && currentRect.width === 0)\n      if (hiddenDueToDimensions || differenceTooSmall) {\n        return false\n      }\n\n      const currentTransform = Rematrix.parse(\n        flippedElementPositionsAfterUpdate[id].transform\n      )\n\n      const toVals: AnimatedVals = { matrix: currentTransform }\n\n      const fromVals: AnimatedVals = { matrix: [] }\n      const transformsArray = [currentTransform]\n\n      // we're only going to animate the values that the child wants animated\n      if (flipConfig.translate) {\n        transformsArray.push(\n          Rematrix.translateX(prevRect.left - currentRect.left)\n        )\n        transformsArray.push(\n          Rematrix.translateY(prevRect.top - currentRect.top)\n        )\n      }\n      // going any smaller than 1px breaks transitions in Chrome\n      if (flipConfig.scale) {\n        transformsArray.push(\n          Rematrix.scaleX(\n            Math.max(prevRect.width, 1) / Math.max(currentRect.width, 1)\n          )\n        )\n        transformsArray.push(\n          Rematrix.scaleY(\n            Math.max(prevRect.height, 1) / Math.max(currentRect.height, 1)\n          )\n        )\n      }\n\n      if (flipConfig.opacity) {\n        fromVals.opacity = prevOpacity\n        toVals.opacity = currentOpacity\n      }\n\n      let invertedChildren: InvertedChildren = []\n\n      if (\n        !flipCallbacks[id] ||\n        !flipCallbacks[id].shouldInvert ||\n        flipCallbacks[id].shouldInvert!(\n          decisionData.previous,\n          decisionData.current\n        )\n      ) {\n        const invertedChildElements = getInvertedChildren(element, id)\n        invertedChildren = invertedChildElements.map(c => [\n          c,\n          extractFlipConfig(c)\n        ]) as InvertedChildren\n      }\n\n      fromVals.matrix = convertMatrix3dArrayTo2dArray(\n        transformsArray.reduce(Rematrix.multiply)\n      )\n\n      toVals.matrix = convertMatrix3dArrayTo2dArray(toVals.matrix)\n\n      const applyStyles = createApplyStylesFunc({\n        element,\n        invertedChildren,\n        body\n      })\n\n      let onComplete: () => void\n      if (flipCallbacks[id] && flipCallbacks[id].onComplete) {\n        // must cache or else this could cause an error\n        const cachedOnComplete = flipCallbacks[id].onComplete\n        onComplete = () => cachedOnComplete!(element, decisionData)\n      }\n\n      // this should be called when animation ends naturally\n      // but also when it is interrupted\n      // when it is called, the animation has already been cancelled\n      const onAnimationEnd = (isCancellation: boolean) => {\n        delete inProgressAnimations[id]\n        if (isFunction(onComplete)) {\n          onComplete()\n        }\n        // remove identity transform -- this should have no effect on layout\n        element.style.transform = ''\n        invertedChildren.forEach(([element]) => {\n          element.style.transform = ''\n        })\n        if (needsForcedMinVals && element) {\n          element.style.minHeight = ''\n          element.style.minWidth = ''\n        }\n        if (isCancellation) return\n\n        completedAnimationIds.push(id)\n\n        if (completedAnimationIds.length >= flipDataArray.length) {\n          // we can theoretically call multiple times since a promise only resolves 1x\n          // but that shouldnt happen\n          closureResolve(completedAnimationIds)\n        }\n      }\n\n      const animateOpacity =\n        isNumber(fromVals.opacity) &&\n        isNumber(toVals.opacity) &&\n        fromVals.opacity !== toVals.opacity\n\n      let onStartCalled = false\n\n      const getOnUpdateFunc: GetOnUpdateFunc = ({ spring, onAnimationEnd }) => {\n        inProgressAnimations[id] = {\n          destroy: spring.destroy.bind(spring),\n          onAnimationEnd\n        }\n        const onUpdate: OnUpdate = spring => {\n          if (flipCallbacks[id] && flipCallbacks[id].onSpringUpdate) {\n            flipCallbacks[id].onSpringUpdate!(spring.getCurrentValue())\n          }\n          // trigger the user provided onStart function\n          if (!onStartCalled) {\n            onStartCalled = true\n            if (flipCallbacks[id] && flipCallbacks[id].onStart) {\n              flipCallbacks[id].onStart!(element, decisionData)\n            }\n          }\n\n          const currentValue = spring.getCurrentValue()\n          if (!body.contains(element)) {\n            spring.destroy()\n            return\n          }\n\n          const vals: AnimatedVals = { matrix: [] }\n\n          vals.matrix = fromVals.matrix.map((fromVal, index) =>\n            tweenProp(fromVal, toVals.matrix[index], currentValue)\n          )\n\n          if (animateOpacity) {\n            vals.opacity = tweenProp(\n              fromVals.opacity!,\n              toVals.opacity!,\n              currentValue\n            )\n          }\n          applyStyles(vals)\n        }\n        return onUpdate\n      }\n\n      const initializeFlip: InitializeFlip = () => {\n        // before animating, immediately apply FLIP styles to prevent flicker\n        applyStyles({\n          matrix: fromVals.matrix,\n          opacity: animateOpacity ? fromVals.opacity : undefined,\n          forceMinVals: needsForcedMinVals\n        })\n\n        if (flipCallbacks[id] && flipCallbacks[id].onStartImmediate) {\n          flipCallbacks[id].onStartImmediate!(element, decisionData)\n        }\n        // and batch any other style updates if necessary\n        if (flipConfig.transformOrigin) {\n          element.style.transformOrigin = flipConfig.transformOrigin\n        } else if (applyTransformOrigin) {\n          element.style.transformOrigin = '0 0'\n        }\n\n        invertedChildren.forEach(([child, childFlipConfig]) => {\n          if (childFlipConfig.transformOrigin) {\n            child.style.transformOrigin = childFlipConfig.transformOrigin\n          } else if (applyTransformOrigin) {\n            child.style.transformOrigin = '0 0'\n          }\n        })\n      }\n\n      return assign({}, toReturn, {\n        stagger,\n        springConfig,\n        getOnUpdateFunc,\n        initializeFlip,\n        onAnimationEnd,\n        delayUntil: flipConfig.delayUntil\n      }) as FlipData\n    })\n    // filter out data for all non-animated elements first\n    .filter(Boolean) as FlipDataArray\n\n  flipDataArray.forEach(({ initializeFlip }) => initializeFlip())\n\n  if (debug) {\n    return () => {}\n  }\n\n  const elementIsFlipped = (flipId: FlipId) =>\n    flipDataArray.filter(f => f.id === flipId).length\n\n  const delayedFlip = flipDataArray.filter(\n    f => f.delayUntil && elementIsFlipped(f.delayUntil)\n  )\n\n  // key: flipId value: flip to delay until key is called\n  const delayUntilSprings = {} as IndexableObject\n  // key: flipId value: stagger to delay until key is called\n  const delayUntilStaggers = {} as IndexableObject\n  // key: stagger value: true\n  const delayedStaggerKeys = {} as IndexableObject\n\n  delayedFlip.forEach(flip => {\n    if (flip.stagger) {\n      delayedStaggerKeys[flip.stagger] = true\n      if (delayUntilStaggers[flip.delayUntil!])\n        delayUntilStaggers[flip.delayUntil!].push(flip.stagger)\n      else delayUntilStaggers[flip.delayUntil!] = [flip.stagger]\n    } else {\n      if (delayUntilSprings[flip.delayUntil!])\n        delayUntilSprings[flip.delayUntil!].push(flip)\n      else delayUntilSprings[flip.delayUntil!] = [flip]\n    }\n  })\n\n  const staggerDict = flipDataArray\n    .filter(flipData => flipData.stagger)\n    .reduce((acc, curr) => {\n      if (acc[curr.stagger]) {\n        acc[curr.stagger].push(curr)\n      } else {\n        acc[curr.stagger] = [curr]\n      }\n      return acc\n    }, {} as IndexableObject)\n\n  const immediateFlip = flipDataArray.filter(f => delayedFlip.indexOf(f) === -1)\n\n  immediateFlip.forEach(flipData => {\n    flipData.onSpringActivate = () => {\n      if (delayUntilSprings[flipData.id]) {\n        delayUntilSprings[flipData.id].forEach(createSpring)\n      }\n      if (delayUntilStaggers[flipData.id]) {\n        const uniqueStaggerKeys = Object.keys(\n          delayUntilStaggers[flipData.id].reduce(\n            (acc: IndexableObject, curr: string) =>\n              assign(acc, { [curr]: true }),\n            {}\n          )\n        )\n        uniqueStaggerKeys.forEach((staggerKey: string) => {\n          createStaggeredSprings(\n            staggerDict[staggerKey],\n            staggerConfig[staggerKey]\n          )\n        })\n      }\n    }\n  })\n\n  return () => {\n    // if there are no active FLIP animations, immediately resolve the\n    // returned promise\n    if (!flipDataArray.length) {\n      closureResolve([])\n    }\n    // animate non-staggered elements\n    immediateFlip\n      .filter(flipData => {\n        return !flipData.stagger\n      })\n      .forEach(createSpring)\n\n    // animate staggered elements\n    Object.keys(staggerDict).forEach(staggerKey => {\n      if (delayedStaggerKeys[staggerKey]) return\n      createStaggeredSprings(staggerDict[staggerKey], staggerConfig[staggerKey])\n    })\n    return flipCompletedPromise\n  }\n}\n","import { toArray, assign } from '../../utilities'\nimport * as constants from '../../constants'\nimport { BoundingClientRect } from './types'\n\nexport const addTupleToObject = <T>(\n  acc: Record<string, T>,\n  curr: [string, T]\n): Record<string, T> => assign(acc, { [curr[0]]: curr[1] })\n\nexport const getAllElements = (\n  element?: HTMLElement,\n  portalKey?: string\n): HTMLElement[] => {\n  if (portalKey) {\n    return toArray(\n      document.querySelectorAll(`[${constants.DATA_PORTAL_KEY}=\"${portalKey}\"]`)\n    )\n  } else {\n    return toArray(element!.querySelectorAll(`[${constants.DATA_FLIP_ID}]`))\n  }\n}\nexport const getRects = (\n  flippedElements: HTMLElement[]\n): [HTMLElement, BoundingClientRect][] => {\n  return flippedElements.map(\n    (child: HTMLElement): [HTMLElement, BoundingClientRect] => [\n      child,\n      child.getBoundingClientRect()\n    ]\n  )\n}\n","import animateUnflippedElements from './animateUnflippedElements'\nimport animateFlippedElements from './animateFlippedElements'\nimport getFlippedElementPositionsAfterUpdate from './getFlippedElementPositions/getFlippedElementPositionsAfterUpdate'\nimport * as constants from '../constants'\nimport { assign, toArray } from '../utilities'\nimport {\n  GetElement,\n  BaseFlipArgs,\n  OnFlipKeyUpdateArgs,\n  FlippedIds\n} from './types'\nimport { AnimateUnflippedElementsArgs } from './animateUnflippedElements/types'\nimport {\n  AnimateFlippedElementsArgs,\n  ScopedSelector\n} from './animateFlippedElements/types'\n\nlet enabled = true\n\nexport const disableFlip = () => (enabled = false)\n\nexport const enableFlip = () => (enabled = true)\n\nexport const isFlipEnabled = () => enabled\n\nconst createPortalScopedSelector =\n  (portalKey: string) => (selector: string) => {\n    return toArray(\n      document.querySelectorAll(\n        `[${constants.DATA_PORTAL_KEY}=\"${portalKey}\"]${selector}`\n      )\n    )\n  }\nconst createFlipperScopedSelector = (containerEl: HTMLElement) => {\n  const tempFlipperId = Math.random().toFixed(5)\n  containerEl.dataset.flipperId = tempFlipperId\n\n  return (selector: string) => {\n    return toArray(\n      containerEl.querySelectorAll(\n        `[data-flipper-id=\"${tempFlipperId}\"] ${selector}`\n      )\n    )\n  }\n}\nconst createScopedSelector = ({\n  containerEl,\n  portalKey\n}: {\n  containerEl?: HTMLElement\n  portalKey?: string\n}): ScopedSelector => {\n  if (portalKey) {\n    return createPortalScopedSelector(portalKey)\n  } else if (containerEl) {\n    return createFlipperScopedSelector(containerEl)\n  } else {\n    return () => []\n  }\n}\n\nconst createGetElementFunc = (scopedSelector: ScopedSelector): GetElement => {\n  return (id: string) => {\n    return scopedSelector(`[${constants.DATA_FLIP_ID}=\"${id}\"]`)[0]\n  }\n}\n\nexport const onFlipKeyUpdate = ({\n  cachedOrderedFlipIds = [],\n  inProgressAnimations = {},\n  flippedElementPositionsBeforeUpdate = {},\n  flipCallbacks = {},\n  containerEl,\n  applyTransformOrigin,\n  spring,\n  debug,\n  portalKey,\n  staggerConfig = {},\n  decisionData = {},\n  handleEnterUpdateDelete,\n  onComplete,\n  onStart\n}: OnFlipKeyUpdateArgs) => {\n  if (!enabled) return\n  const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)')\n  if (mediaQuery.matches) return\n  const flippedElementPositionsAfterUpdate =\n    getFlippedElementPositionsAfterUpdate({\n      element: containerEl,\n      portalKey\n    })\n\n  const scopedSelector = createScopedSelector({\n    containerEl,\n    portalKey\n  })\n  const getElement = createGetElementFunc(scopedSelector)\n\n  const isFlipped = (id: string) =>\n    flippedElementPositionsBeforeUpdate[id] &&\n    flippedElementPositionsAfterUpdate[id]\n\n  const unflippedIds = Object.keys(flippedElementPositionsBeforeUpdate)\n    .concat(Object.keys(flippedElementPositionsAfterUpdate))\n    .filter(id => !isFlipped(id))\n\n  const baseArgs: BaseFlipArgs = {\n    flipCallbacks,\n    getElement,\n    flippedElementPositionsBeforeUpdate,\n    flippedElementPositionsAfterUpdate,\n    inProgressAnimations,\n    decisionData\n  }\n\n  const animateUnFlippedElementsArgs = assign({}, baseArgs, {\n    unflippedIds\n  }) as AnimateUnflippedElementsArgs\n\n  const {\n    hideEnteringElements,\n    animateEnteringElements,\n    animateExitingElements\n  } = animateUnflippedElements(animateUnFlippedElementsArgs)\n\n  const flippedIds: FlippedIds = cachedOrderedFlipIds.filter(isFlipped)\n  // @ts-ignore\n  const animateFlippedElementsArgs: AnimateFlippedElementsArgs = assign(\n    {},\n    baseArgs,\n    {\n      containerEl,\n      flippedIds,\n      applyTransformOrigin,\n      spring,\n      debug,\n      staggerConfig,\n      scopedSelector,\n      onComplete\n    }\n  )\n  if (onStart) onStart(containerEl, decisionData)\n\n  // the function handles putting flipped elements back in their original positions\n  // and returns another function to actually call the flip animation\n  const flip = animateFlippedElements(animateFlippedElementsArgs)\n\n  if (handleEnterUpdateDelete) {\n    handleEnterUpdateDelete({\n      hideEnteringElements,\n      animateEnteringElements,\n      animateExitingElements,\n      animateFlippedElements: flip\n    })\n  } else {\n    hideEnteringElements()\n    animateExitingElements().then(animateEnteringElements)\n    flip()\n  }\n}\n\n","import { addTupleToObject, getRects, getAllElements } from '../utilities'\nimport {\n  FlippedElementPositionsAfterUpdate,\n  FlippedElementPositionDatumAfterUpdate\n} from './types'\n\nconst getFlippedElementPositionsAfterUpdate = ({\n  element,\n  portalKey\n}: {\n  element: HTMLElement\n  portalKey?: string\n}): FlippedElementPositionsAfterUpdate => {\n  const positionArray = getRects(getAllElements(element, portalKey)).map(\n    ([child, childBCR]) => {\n      const computedStyle = window.getComputedStyle(child)\n      return [\n        child.dataset.flipId,\n        {\n          element: child,\n          rect: childBCR,\n          opacity: parseFloat(computedStyle.opacity!),\n          transform: computedStyle.transform\n        }\n      ]\n    }\n  ) as [string, FlippedElementPositionDatumAfterUpdate][]\n\n  return positionArray.reduce(addTupleToObject, {})\n}\n\nexport default getFlippedElementPositionsAfterUpdate\n","import { AnimateUnflippedElementsArgs, FragmentTuple } from './types'\n\nconst animateUnflippedElements = ({\n  unflippedIds,\n  flipCallbacks,\n  getElement,\n  flippedElementPositionsBeforeUpdate,\n  flippedElementPositionsAfterUpdate,\n  inProgressAnimations,\n  decisionData\n}: AnimateUnflippedElementsArgs) => {\n  const enteringElementIds = unflippedIds.filter(\n    id => flippedElementPositionsAfterUpdate[id]\n  )\n  const animatedEnteringElementIds = enteringElementIds.filter(\n    id => flipCallbacks[id] && flipCallbacks[id].onAppear\n  )\n\n  const animatedExitingElementIds = unflippedIds.filter(\n    id =>\n      flippedElementPositionsBeforeUpdate[id] &&\n      flipCallbacks[id] &&\n      flipCallbacks[id].onExit\n  )\n\n  const hideEnteringElements = () => {\n    animatedEnteringElementIds.forEach(id => {\n      const element = getElement(id)\n      if (element) {\n        element.style.opacity = '0'\n      }\n    })\n  }\n\n  const animateEnteringElements = () => {\n    animatedEnteringElementIds.forEach((id, i) => {\n      const element = getElement(id)\n      if (element) {\n        flipCallbacks[id].onAppear!(element, i, decisionData)\n      }\n    })\n  }\n\n  let closureResolve: () => void\n\n  const promiseToReturn: Promise<void> = new Promise(resolve => {\n    closureResolve = resolve\n  })\n\n  const fragmentTuples: FragmentTuple[] = []\n  let exitingElementCount = 0\n\n  const onExitCallbacks = animatedExitingElementIds.map((id, i) => {\n    const {\n      domDataForExitAnimations: {\n        element,\n        parent,\n        childPosition: { top, left, width, height }\n      }\n    } = flippedElementPositionsBeforeUpdate[id]\n    // insert back into dom\n    if (getComputedStyle(parent).position === 'static') {\n      parent.style.position = 'relative'\n    }\n    element.style.transform = 'matrix(1, 0, 0, 1, 0, 0)'\n    element.style.position = 'absolute'\n    element.style.top = top + 'px'\n    element.style.left = left + 'px'\n    // taken out of the dom flow, the element might have lost these dimensions\n    element.style.height = height + 'px'\n    element.style.width = width + 'px'\n    let fragmentTuple: FragmentTuple | undefined = fragmentTuples.filter(\n      t => t[0] === parent\n    )[0]\n    if (!fragmentTuple) {\n      fragmentTuple = [parent, document.createDocumentFragment()]\n      fragmentTuples.push(fragmentTuple)\n    }\n    fragmentTuple[1].appendChild(element)\n\n    exitingElementCount += 1\n\n    const stop = () => {\n      try {\n        parent.removeChild(element)\n      } catch (DOMException) {\n        // the element is already gone\n      } finally {\n        exitingElementCount -= 1\n        if (exitingElementCount === 0) {\n          closureResolve()\n        }\n      }\n    }\n    // @ts-ignore\n    inProgressAnimations[id] = { stop }\n    return () => flipCallbacks[id].onExit!(element, i, stop, decisionData)\n  })\n\n  // now append all the fragments from the onExit callbacks\n  // (we use fragments for performance)\n  fragmentTuples.forEach(t => {\n    t[0].appendChild(t[1])\n  })\n\n  if (!onExitCallbacks.length) {\n    closureResolve!()\n  }\n\n  const animateExitingElements = () => {\n    onExitCallbacks.forEach(c => c())\n    return promiseToReturn\n  }\n\n  return {\n    hideEnteringElements,\n    animateEnteringElements,\n    animateExitingElements\n  }\n}\n\nexport default animateUnflippedElements\n","import { addTupleToObject, getAllElements, getRects } from '../utilities'\nimport * as constants from '../../../constants'\nimport { toArray, assign } from '../../../utilities'\nimport {\n  FlippedElementPositionsBeforeUpdateReturnVals,\n  FlippedElementPositionDatumBeforeUpdate,\n  GetFlippedElementPositionsBeforeUpdateArgs,\n  ParentBCRs,\n  ChildIdsToParentBCRs,\n  ChildIdsToParents\n} from './types'\nimport { InProgressAnimations } from '../../../types'\n\nexport const cancelInProgressAnimations = (\n  inProgressAnimations: InProgressAnimations,\n  animatingElements: HTMLElement[]\n) => {\n  Object.keys(inProgressAnimations).forEach(id => {\n    if (inProgressAnimations[id].destroy) {\n      inProgressAnimations[id].destroy!()\n    }\n    if (inProgressAnimations[id].onAnimationEnd) {\n      inProgressAnimations[id].onAnimationEnd!(true)\n    }\n    delete inProgressAnimations[id]\n  })\n  animatingElements.forEach(el => {\n    el.style.transform = ''\n    el.style.opacity = ''\n  })\n}\n\nconst getFlippedElementPositionsBeforeUpdate = ({\n  element,\n  flipCallbacks = {},\n  inProgressAnimations = {},\n  portalKey\n}: GetFlippedElementPositionsBeforeUpdateArgs): FlippedElementPositionsBeforeUpdateReturnVals => {\n  const flippedElements = getAllElements(element, portalKey)\n\n  const inverseFlippedElements = toArray(\n    element.querySelectorAll(`[${constants.DATA_INVERSE_FLIP_ID}]`)\n  )\n\n  const childIdsToParentBCRs: ChildIdsToParentBCRs = {}\n  const parentBCRs: ParentBCRs = []\n  const childIdsToParents: ChildIdsToParents = {}\n  // this is for exit animations so we can re-insert exiting elements in the\n  // DOM later\n  flippedElements\n    .filter(\n      el =>\n        flipCallbacks &&\n        flipCallbacks[el.dataset.flipId!] &&\n        flipCallbacks[el.dataset.flipId!].onExit\n    )\n    .forEach(el => {\n      let parent = el.parentNode as HTMLElement\n      // this won't work for IE11\n      if (el.closest) {\n        const exitContainer = el.closest(\n          `[${constants.DATA_EXIT_CONTAINER}]`\n        ) as HTMLElement\n        if (exitContainer) {\n          parent = exitContainer\n        }\n      }\n      let bcrIndex = parentBCRs.findIndex(n => n[0] === parent)\n      if (bcrIndex === -1) {\n        parentBCRs.push([parent, parent.getBoundingClientRect()])\n        bcrIndex = parentBCRs.length - 1\n      }\n      childIdsToParentBCRs[el.dataset.flipId!] = parentBCRs[bcrIndex][1]\n      childIdsToParents[el.dataset.flipId!] = parent\n    })\n\n  const filteredFlippedElements = getRects(flippedElements)\n\n  const flippedElementPositionsTupleArray: [\n    string,\n    FlippedElementPositionDatumBeforeUpdate\n  ][] = filteredFlippedElements.map(([child, childBCR]) => {\n    const domDataForExitAnimations = {}\n\n    // only cache extra data for exit animations\n    // if the element has an onExit listener\n    if (\n      flipCallbacks &&\n      flipCallbacks[child.dataset.flipId!] &&\n      flipCallbacks[child.dataset.flipId!].onExit\n    ) {\n      const parentBCR = childIdsToParentBCRs[child.dataset.flipId!]\n\n      assign(domDataForExitAnimations, {\n        element: child,\n        parent: childIdsToParents[child.dataset.flipId!],\n        childPosition: {\n          top: childBCR.top - parentBCR.top,\n          left: childBCR.left - parentBCR.left,\n          width: childBCR.width,\n          height: childBCR.height\n        }\n      })\n    }\n\n    return [\n      child.dataset.flipId!,\n      {\n        rect: childBCR,\n        opacity: parseFloat(window.getComputedStyle(child).opacity || '1'),\n        domDataForExitAnimations\n      }\n    ]\n  }) as [string, FlippedElementPositionDatumBeforeUpdate][]\n\n  const flippedElementPositions = flippedElementPositionsTupleArray.reduce(\n    addTupleToObject,\n    {}\n  )\n\n  // do this at the very end since we want to cache positions of elements\n  // while they are mid-transition\n  cancelInProgressAnimations(\n    inProgressAnimations,\n    flippedElements.concat(inverseFlippedElements)\n  )\n\n  return {\n    flippedElementPositions,\n    cachedOrderedFlipIds: filteredFlippedElements.map(\n      ([el]) => el.dataset.flipId!\n    )\n  }\n}\n\nexport default getFlippedElementPositionsBeforeUpdate\n","import { onFlipKeyUpdate } from './flip'\nimport getFlippedElementPositionsBeforeUpdate from './flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate'\nimport { assign } from './utilities'\nimport {\n  StaggerConfig,\n  HandleEnterUpdateDelete,\n  InProgressAnimations,\n  FlipCallbacks,\n  OnFlipperComplete,\n  FlippedProps,\n  OnFlipperStart\n} from './types'\nimport { SpringOption } from './springSettings/types'\nimport { FlippedElementPositionsBeforeUpdate } from './flip/getFlippedElementPositions/getFlippedElementPositionsBeforeUpdate/types'\nimport { FlippedIds } from './flip/types'\n\ninterface Options {\n  element: HTMLElement\n  staggerConfig?: StaggerConfig\n  spring?: SpringOption\n  applyTransformOrigin?: boolean\n  handleEnterUpdateDelete?: HandleEnterUpdateDelete\n  debug?: boolean\n  onStart?: OnFlipperStart\n  onComplete?: OnFlipperComplete\n}\n\nclass Flipper {\n  private element!: HTMLElement\n  private staggerConfig!: StaggerConfig\n  private applyTransformOrigin = true\n  private handleEnterUpdateDelete!: HandleEnterUpdateDelete\n  private debug?: boolean\n  private spring!: SpringOption\n  private inProgressAnimations: InProgressAnimations\n  private flipCallbacks: FlipCallbacks\n  private snapshot?: {\n    flippedElementPositions: FlippedElementPositionsBeforeUpdate\n    cachedOrderedFlipIds: FlippedIds\n  }\n  private onComplete?: OnFlipperComplete\n  private onStart?: OnFlipperStart\n\n  constructor(options: Options) {\n    assign(this, options)\n\n    this.inProgressAnimations = {}\n    this.flipCallbacks = {}\n\n    this.recordBeforeUpdate = this.recordBeforeUpdate.bind(this)\n    this.update = this.update.bind(this)\n    this.addFlipped = this.addFlipped.bind(this)\n    this.addInverted = this.addInverted.bind(this)\n  }\n\n  recordBeforeUpdate() {\n    this.snapshot = getFlippedElementPositionsBeforeUpdate({\n      element: this.element,\n      flipCallbacks: this.flipCallbacks,\n      inProgressAnimations: this.inProgressAnimations\n    })\n  }\n  update(prevDecisionData: any, currentDecisionData: any) {\n    if (this.snapshot) {\n      onFlipKeyUpdate({\n        flippedElementPositionsBeforeUpdate:\n          this.snapshot.flippedElementPositions,\n        cachedOrderedFlipIds: this.snapshot.cachedOrderedFlipIds,\n        containerEl: this.element,\n        inProgressAnimations: this.inProgressAnimations,\n        flipCallbacks: this.flipCallbacks,\n        applyTransformOrigin: this.applyTransformOrigin,\n        spring: this.spring,\n        debug: this.debug,\n        staggerConfig: this.staggerConfig,\n        handleEnterUpdateDelete: this.handleEnterUpdateDelete,\n        decisionData: {\n          previous: prevDecisionData,\n          current: currentDecisionData\n        },\n        onComplete: this.onComplete,\n        onStart: this.onStart\n      })\n      delete this.snapshot\n    }\n  }\n\n  addFlipped({\n    element,\n    flipId,\n    opacity,\n    translate,\n    scale,\n    transformOrigin,\n    spring,\n    stagger,\n    delayUntil,\n    onAppear,\n    onStart,\n    onSpringUpdate,\n    onComplete,\n    onExit,\n    shouldFlip,\n    shouldInvert\n  }: FlippedProps & { element: HTMLElement }) {\n    if (!element) {\n      throw new Error('no element provided')\n    }\n    if (!flipId) {\n      throw new Error('No flipId provided')\n    }\n    const flipConfig = {\n      scale,\n      translate,\n      opacity,\n      transformOrigin,\n      spring,\n      stagger,\n      delayUntil\n    }\n    if (!flipConfig.scale && !flipConfig.translate && !flipConfig.opacity) {\n      assign(flipConfig, {\n        translate: true,\n        scale: true,\n        opacity: true\n      })\n    }\n    if (flipId) {\n      element.dataset.flipId = String(flipId)\n    }\n    element.dataset.flipConfig = JSON.stringify(flipConfig)\n    // finally, add callbacks\n    this.flipCallbacks[flipId] = {\n      shouldFlip,\n      shouldInvert,\n      onAppear,\n      onStart,\n      onSpringUpdate,\n      onComplete,\n      onExit\n    }\n  }\n\n  addInverted({\n    element,\n    parent,\n    opacity,\n    translate,\n    scale,\n    transformOrigin\n  }: {\n    element: HTMLElement\n    parent: HTMLElement\n    opacity: boolean\n    translate: boolean\n    scale: boolean\n    transformOrigin: string\n  }) {\n    if (!element) {\n      throw new Error('no element provided')\n    }\n    if (!parent) {\n      throw new Error('parent must be provided')\n    }\n\n    const inverseFlipId = parent.dataset.flipId\n    const flipConfig = {\n      scale,\n      translate,\n      opacity,\n      transformOrigin\n    }\n    if (!flipConfig.scale && !flipConfig.translate && !flipConfig.opacity) {\n      assign(flipConfig, {\n        translate: true,\n        scale: true,\n        opacity: true\n      })\n    }\n    element.dataset.inverseFlipId = inverseFlipId\n    element.dataset.flipConfig = JSON.stringify(flipConfig)\n  }\n}\n\nexport default Flipper\n","// this is exclusively for users of the library to create their own enter + exit animations\nimport { SpringSystem } from '../forked-rebound'\nimport { SpringSystemInterface } from '../forked-rebound/types.d'\nimport { tweenProp, assign } from '../utilities'\nimport { normalizeSpring, springPresets } from '../springSettings'\nimport { SimpleSpringOptions } from './types'\nimport { SpringConfig } from '../springSettings/types'\n\n// this should get created only 1x\nconst springSystem: SpringSystemInterface = new SpringSystem()\n\n/**\n * A simple spring function for animating DOM properties.\n * Returns a function that will immediately cancel the in-progress animation.\n * */\nconst createSimpleSpring = ({\n  config,\n  values,\n  onUpdate,\n  delay = 0,\n  onComplete\n}: SimpleSpringOptions) => {\n  const { stiffness, damping, overshootClamping } = assign(\n    {},\n    springPresets.noWobble,\n    normalizeSpring(config)\n  ) as SpringConfig\n  const spring = springSystem.createSpring(stiffness!, damping!)\n  spring.setOvershootClampingEnabled(!!overshootClamping)\n  spring.addListener({\n    onSpringAtRest: spring => {\n      if (onComplete) onComplete()\n      spring.destroy()\n    },\n    onSpringUpdate: spring => {\n      const springVal = spring.getCurrentValue()\n      if (!values) return onUpdate(springVal)\n      const currentValues = Object.keys(values)\n        .map(value => [\n          value,\n          tweenProp(values[value][0], values[value][1], springVal)\n        ])\n        .reduce((acc, curr) => {\n          return Object.assign(acc, { [curr[0]]: curr[1] })\n        }, {})\n      onUpdate(currentValues)\n    }\n  })\n  if (delay) {\n    setTimeout(() => {\n      spring.setEndValue(1)\n    }, delay)\n  } else {\n    spring.setEndValue(1)\n  }\n  return spring\n}\n\nexport default createSimpleSpring\n"],"mappings":";AAEa,IAAAA,CAAA,GAAW,SAAAC,CAACC,CAAA;IAAM,OAAkB,mBAANA,CAAc;EAAA;EAE5CC,CAAA,GAAa,SAAAC,CAACF,CAAA;IAAW,OAAa,qBAANA,CAAgB;EAAA;EAEhDG,CAAA,GAAW,SAAAC,CAACJ,CAAA;IAAM,OACS,sBAAtCK,MAAA,CAAOC,SAAA,CAAUC,QAAA,CAASC,IAAA,CAAKR,CAAA,CAAwB;EAAA;EAE5CS,CAAA,GAAU,SAAAC,CAACV,CAAA;IACtB,OAAAW,KAAA,CAAML,SAAA,CAAUM,KAAA,CAAMC,KAAA,CAAMb,CAAA,CAAU;EAAA;EAE3Bc,CAAA,GAA4B,SAAAC,CAACf,CAAA;IACxC,IACMF,CAAA,GAAME,CAAA,CAAIgB,MAAA,CAAO,UAAChB,CAAA,EAAKF,CAAA;MAE3B,OADAE,CAAA,CAAIF,CAAA,KAASE,CAAA,CAAIF,CAAA,KAAS,KAAK,GACxBE,CACT;IAAA,GAJiC;IAKjC,OAAOK,MAAA,CAAOY,IAAA,CAAKnB,CAAA,EAAKoB,MAAA,CAAO,UAAAlB,CAAA;MAAG,OAAIF,CAAA,CAAIE,CAAA,IAAO,CAAC;IAAA,EACpD;EAAA;AAAA,SAGgBmB,EAAOnB,CAAA;EAarB,OAZA,GAAAY,KAAA,CAAAJ,IAAA,CAAAY,SAAA,EAAK,GAAAC,OAAA,CAAQ,UAAAvB,CAAA;IACX,IAAKA,CAAA,EAIL,KAAK,IAAMG,CAAA,IAAWH,CAAA,EAEhBO,MAAA,CAAOC,SAAA,CAAUgB,cAAA,CAAed,IAAA,CAAKV,CAAA,EAAKG,CAAA,MAC5CD,CAAA,CAAOC,CAAA,IAAWH,CAAA,CAAIG,CAAA,EAG5B;EAAA,IACOD,CACT;AAAA;AAEO,IC3BHuB,CAAA;ED2BSC,CAAA,GAAY,SAAAC,CAACzB,CAAA,EAAeF,CAAA,EAAaG,CAAA;IACpD,OAAAD,CAAA,IAASF,CAAA,GAAME,CAAA,IAASC,CAAQ;EAAA;EAAAyB,CAAA;IAAAC,SAAA;IAAA5B,QAAA,EAAAD,CAAA;IAAAI,UAAA,EAAAD,CAAA;IAAAG,QAAA,EAAAD,CAAA;IAAAO,OAAA,EAAAD,CAAA;IAAAM,yBAAA,EAAAD,CAAA;IAAAc,MAAA,EAAAT,CAAA;IAAAM,SAAA,EAAAD;EAAA;EEvCrBK,CAAA,GAAe;EACfC,CAAA,GAAuB;EAGvBC,CAAA,GAAkB;EAClBC,CAAA,GAAsB;EAAAC,CAAA;IAAAN,SAAA;IAAAO,YAAA,EAAAL,CAAA;IAAAM,oBAAA,EAAAL,CAAA;IAAAM,sBAAA,EAHG;IAAAC,gBAAA,EACN;IAAAC,eAAA,EAAAP,CAAA;IAAAQ,mBAAA,EAAAP;EAAA;ECEnBQ,CAAA,GAA+B;IAC1CC,QAAA,EAAU;MAAEC,SAAA,EAAW;MAAKC,OAAA,EAAS;IAAA;IACrCC,MAAA,EAAQ;MAAEF,SAAA,EAAW;MAAKC,OAAA,EAAS;IAAA;IACnCE,UAAA,EAAY;MAAEH,SAAA,EAAW;MAAKC,OAAA,EAAS;IAAA;IACvCG,MAAA,EAAQ;MAAEJ,SAAA,EAAW;MAAKC,OAAA,EAAS;IAAA;IACnCI,KAAA,EAAO;MAAEL,SAAA,EAAW;MAAKC,OAAA,EAAS;IAAA;EAAA;EASvBK,CAAA,GAAkB,SAAAC,CAC7BjD,CAAA;IAEA,OANOG,CAAA,CAMeH,CAAA,IACbA,CAAA,GACEK,MAAA,CAAOY,IAAA,CAAKuB,CAAA,EAAeU,OAAA,CAAQlD,CAAA,KAAW,IAChDwC,CAAA,CAAcxC,CAAA,IAEd,EAEX;EAAA;AFjBsB,sBAAXmD,MAAA,KACT5B,CAAA,GAAW4B,MAAA,CAAOC,qBAAA;AASpB,IAAAC,CAAA,GANA9B,CAAA,GACEA,CAAA,IACA,UAASvB,CAAA;IACPmD,MAAA,CAAOG,UAAA,CAAWtD,CAAA,EAAU,MAAO,GACrC;EAAA;EGPIuD,CAAA,GAAQC,IAAA,CAAKC,GAAA;EACNC,CAAA,GACY,mBAAhBC,WAAA,IAAuD,qBAApBA,WAAA,CAAYF,GAAA,GAClD;IAAA,OAAME,WAAA,CAAYF,GAAA,EAAK;EAAA,IACvB;IAAA,OAAMD,IAAA,CAAKC,GAAA,KAAQF,CAAK;EAAA;AAGd,SAAAK,EAAY5D,CAAA,EAAOF,CAAA;EACjC,IAAMG,CAAA,GAAMD,CAAA,CAAMkD,OAAA,CAAQpD,CAAA;EAAA,CACjB,MAATG,CAAA,IAAcD,CAAA,CAAM6D,MAAA,CAAO5D,CAAA,EAAK,EAClC;AAAA;ACJA,IAAa6D,CAAA,gBAAe;IAAA,SAAA9D,EAAA;IAKzB,OALyBA,CAAA,CAAAM,SAAA,CAC1ByD,GAAA;MAAM,IAAA/D,CAAA,GACJ;MAAAqD,CAAA,CAAQ;QACNrD,CAAA,CAAKgE,YAAA,CAAaC,IAAA,CAAKP,CAAA,GACzB;MAAA,EACF;IAAA,GAAC1D,CAAA;EAAA,CALyB;ECNtBkE,CAAA,GACJ,SAAAC,CAAA;IACE,KAAKC,QAAA,GAAW,GAChB,KAAKC,QAAA,GAAW,CAClB;EAAA;EAGEC,CAAA,GAAK;EAEHC,CAAA,GAAsB;EAiBtBC,CAAA,gBACJ;IAAA,SAAAxE,EAAYA,CAAA;MACV,KAAKyE,GAAA,GAAU,MAAAH,CAAA,IACf,KAAKI,aAAA,GAAgB1E,CAAA,EAErB,KAAK2E,SAAA,GAAY,IACjB,KAAKC,WAAA,GAAc,GAEnB,KAAKC,aAAA,GAAgB,IAAIX,CAAA,IACzB,KAAKY,8BAAA,GAAiC,MACtC,KAAKC,SAAA,GAAY,GACjB,KAAKC,yBAAA,IAA4B,GACjC,KAAKC,cAAA,GAAiB,IAAIf,CAAA,IAC1B,KAAKgB,mBAAA,GAAsB,MAE3B,KAAKC,UAAA,GAAa,IAAIjB,CAAA,IACtB,KAAKkB,gBAAA,GAAmB,GACxB,KAAKC,UAAA,IAAa,GAGlB,KAAKC,mBAAA,GAAsB,EAC7B;IAAA;IAAC,IAAAxF,CAAA,GAAAE,CAAA,CAAAM,SAAA;IAAA,OAAAR,CAAA,CAEDyF,KAAA;MACE,OAAO,KAAKd,GACd;IAAA,GAAC3E,CAAA,CAMD0F,OAAA;MACE,KAAKb,SAAA,GAAY,IACjB,KAAKD,aAAA,CAAce,gBAAA,CAAiB,KACtC;IAAA,GAAC3F,CAAA,CAQD4F,eAAA,aAAgB1F,CAAA;MAEd,OADA,KAAK2F,aAAA,GAAgB3F,CAAA,EACd,IACT;IAAA,GAACF,CAAA,CAKD8F,eAAA;MACE,OAAO,KAAKf,aAAA,CAAcT,QAC5B;IAAA,GAACtE,CAAA,CAKD+F,+BAAA,aAAgC7F,CAAA;MAC9B,OAAO8F,IAAA,CAAKC,GAAA,CAAI,KAAKhB,SAAA,GAAY/E,CAAA,CAAMoE,QAAA,CACzC;IAAA,GAACtE,CAAA,CAYDkG,WAAA,aAAYhG,CAAA;MACV,IAAIA,CAAA,KAAa,KAAK+E,SAAA,EAAW;MAEjC,IADA,KAAKkB,YAAA,GAAejG,CAAA,EAChB,KAAK+E,SAAA,KAAc/E,CAAA,IAAY,KAAKkG,QAAA,IACtC,OAAO;MAET,KAAKtB,WAAA,GAAc,KAAKgB,eAAA,IACxB,KAAKb,SAAA,GAAY/E,CAAA,EACjB,KAAK0E,aAAA,CAAcyB,cAAA,CAAe,KAAKZ,KAAA;MACvC,KAAK,IAAIzF,CAAA,GAAI,GAAGG,CAAA,GAAM,KAAK0E,SAAA,CAAUyB,MAAA,EAAQtG,CAAA,GAAIG,CAAA,EAAKH,CAAA,IAAK;QACzD,IACMK,CAAA,GADW,KAAKwE,SAAA,CAAU7E,CAAA,EACNuG,sBAAA;QAC1BlG,CAAA,IAAYA,CAAA,CAAS,KACvB;MAAA;MACA,OAAO,IACT;IAAA,GAACL,CAAA,CAYDwG,WAAA,aAAYtG,CAAA;MACV,OAAIA,CAAA,KAAa,KAAK6E,aAAA,CAAcR,QAAA,KAGpC,KAAKQ,aAAA,CAAcR,QAAA,GAAWrE,CAAA,EAC9B,KAAK0E,aAAA,CAAcyB,cAAA,CAAe,KAAKZ,KAAA,MAFvC,IAIF;IAAA,GAACzF,CAAA,CAEDyG,eAAA,aAAgBvG,CAAA;MACd,KAAK4E,WAAA,GAAc5E,CAAA,EACnB,KAAK6E,aAAA,CAAcT,QAAA,GAAWpE,CAAA;MAC9B,KAAK,IAAIF,CAAA,GAAI,GAAGG,CAAA,GAAM,KAAK0E,SAAA,CAAUyB,MAAA,EAAQtG,CAAA,GAAIG,CAAA,EAAKH,CAAA,IAAK;QACzD,IAAIK,CAAA,GAAW,KAAKwE,SAAA,CAAU7E,CAAA;QAC9BK,CAAA,CAASqG,cAAA,IAAkBrG,CAAA,CAASqG,cAAA,CAAe,KACrD;MAAA;MACA,OACF;IAAA,GAAC1G,CAAA,CAED2G,SAAA;MAIE,OAHA,KAAK1B,SAAA,GAAY,KAAKF,aAAA,CAAcT,QAAA,EACpC,KAAKe,UAAA,CAAWf,QAAA,GAAW,KAAKS,aAAA,CAAcT,QAAA,EAC9C,KAAKS,aAAA,CAAcR,QAAA,GAAW,GAEhC;IAAA,GAACvE,CAAA,CAUD4G,2BAAA,aAA4B1G,CAAA;MAE1B,OADA,KAAKgF,yBAAA,GAA4BhF,CAAA,EAC1B,IACT;IAAA,GAACF,CAAA,CAQD6G,cAAA;MACE,IAAM3G,CAAA,GAAQ,KAAK4E,WAAA;QACb9E,CAAA,GAAM,KAAKiF,SAAA;MACjB,YACOY,aAAA,CAAciB,OAAA,GAAU,MAC3B5G,CAAA,GAAQF,CAAA,IAAO,KAAK8F,eAAA,KAAoB9F,CAAA,IACvCE,CAAA,GAAQF,CAAA,IAAO,KAAK8F,eAAA,KAAoB9F,CAAA,CAE/C;IAAA,GAACA,CAAA,CAUD+G,OAAA,aAAQ7G,CAAA,EAAMF,CAAA;MACZ,IAAIG,CAAA,GAAW,KAAKiG,QAAA;MAEpB,KAAIjG,CAAA,KAAY,KAAKoF,UAAA,EAArB;QAIA,IAAIlF,CAAA,GAAoBL,CAAA;QACpBA,CAAA,GA3LmB,SA4LrBK,CAAA,GA5LqB,OA+LvB,KAAKiF,gBAAA,IAAoBjF,CAAA;QAmBzB,KAjBA,IAMIM,CAAA,EACAK,CAAA,EACAK,CAAA,EACAI,CAAA,EACAC,CAAA,EACAE,CAAA,EAXEG,CAAA,GAAU,KAAK8D,aAAA,CAAciB,OAAA,EAC7B9E,CAAA,GAAW,KAAK6D,aAAA,CAAcmB,QAAA,EAChC/E,CAAA,GAAW,KAAK8C,aAAA,CAAcT,QAAA,EAC9BpC,CAAA,GAAW,KAAK6C,aAAA,CAAcR,QAAA,EAC9BpC,CAAA,GAAe,KAAKkD,UAAA,CAAWf,QAAA,EAC/B5B,CAAA,GAAe,KAAK2C,UAAA,CAAWd,QAAA,EAY5B,KAAKe,gBAAA,IAAoBb,CAAA,GAC9B,KAAKa,gBAAA,IAAoBb,CAAA,EAErB,KAAKa,gBAAA,GAAmBb,CAAA,KAC1B,KAAKU,cAAA,CAAeb,QAAA,GAAWrC,CAAA,EAC/B,KAAKkD,cAAA,CAAeZ,QAAA,GAAWrC,CAAA,GAIjClB,CAAA,GACEe,CAAA,IAAW,KAAKkD,SAAA,GAAY9C,CAAA,IAAgBH,CAAA,GAAWE,CAAA,EAKzDT,CAAA,GACEM,CAAA,IAAW,KAAKkD,SAAA,IAJlB9C,CAAA,GAAeF,CAAA,IAJftB,CAAA,GAAYuB,CAAA,IAI0BuC,CAAA,GAAsB,OAIdzC,CAAA,IAH9CU,CAAA,GAAeR,CAAA,GAAWlB,CAAA,GAAgByD,CAAA,GAAsB,KAQhE7C,CAAA,GACEG,CAAA,IAAW,KAAKkD,SAAA,IAJlB9C,CAAA,GAAeF,CAAA,IAJfZ,CAAA,GAAYqB,CAAA,IAI0B+B,CAAA,GAAsB,OAIdzC,CAAA,IAH9CU,CAAA,GAAeR,CAAA,GAAWT,CAAA,GAAgBgD,CAAA,GAAsB,KAKhEtC,CAAA,GAAeF,CAAA,IAJfP,CAAA,GAAYgB,CAAA,IAI0B+B,CAAA,EAYtCxC,CAAA,IALG,IAAM,KAAQtB,CAAA,GAAY,KAAOU,CAAA,GAAYK,CAAA,KANhDgB,CAAA,GAAeR,CAAA,GAAWN,CAAA,GAAgB6C,CAAA,KAWvBA,CAAA,EACnBvC,CAAA,IAJG,IAAM,KACNlB,CAAA,GAAgB,KAAOS,CAAA,GAAgBG,CAAA,KANxCG,CAAA,IAAW,KAAKkD,SAAA,GAAY9C,CAAA,IAAgBH,CAAA,GAAWU,CAAA,KAStC+B,CAAA;QAGrB,KAAKY,UAAA,CAAWf,QAAA,GAAWnC,CAAA,EAC3B,KAAKkD,UAAA,CAAWd,QAAA,GAAW7B,CAAA,EAE3B,KAAKqC,aAAA,CAAcT,QAAA,GAAWrC,CAAA,EAC9B,KAAK8C,aAAA,CAAcR,QAAA,GAAWrC,CAAA,EAE1B,KAAKoD,gBAAA,GAAmB,KAC1B,KAAK2B,YAAA,CAAa,KAAK3B,gBAAA,GAAmBb,CAAA,IAI1C,KAAK2B,QAAA,MACJ,KAAKlB,yBAAA,IAA6B,KAAK2B,cAAA,QAEpC,KAAKhB,aAAA,CAAciB,OAAA,GAAU,KAC/B,KAAKhC,WAAA,GAAc,KAAKG,SAAA,EACxB,KAAKF,aAAA,CAAcT,QAAA,GAAW,KAAKW,SAAA,KAEnC,KAAKA,SAAA,GAAY,KAAKF,aAAA,CAAcT,QAAA,EACpC,KAAKQ,WAAA,GAAc,KAAKG,SAAA,GAE1B,KAAKuB,WAAA,CAAY,IACjBrG,CAAA,IAAW;QAGb,IAAI+C,CAAA,IAAiB;QACjB,KAAKqC,UAAA,KACP,KAAKA,UAAA,IAAa,GAClBrC,CAAA,IAAiB;QAGnB,IAAIK,CAAA,IAAe;QACfpD,CAAA,KACF,KAAKoF,UAAA,IAAa,GAClBhC,CAAA,IAAe,IAGjB,KAAK2D,qBAAA,CAAsBhE,CAAA,EAAgBK,CAAA,CAvG3C;MAAA;IAwGF,GAACvD,CAAA,CAEDkH,qBAAA,aAAsBhH,CAAA,EAAgBF,CAAA;MAAc,IAAAG,CAAA,GAClD;MAAA,KAAK0E,SAAA,CAAUzD,MAAA,CAAO+F,OAAA,EAAS5F,OAAA,CAAQ,UAAAlB,CAAA;QAEnCH,CAAA,IACAG,CAAA,CAAS+G,gBAAA,KACRjH,CAAA,CAAKkH,iBAAA,KAENhH,CAAA,CAAS+G,gBAAA,CAAiBjH,CAAA,GAC1BA,CAAA,CAAKkH,iBAAA,IAAoB,IAGvBhH,CAAA,CAASqG,cAAA,IACXrG,CAAA,CAASqG,cAAA,CAAevG,CAAA,GAGtBH,CAAA,IAAgBK,CAAA,CAASiH,cAAA,IAC3BjH,CAAA,CAASiH,cAAA,CAAenH,CAAA,CAE5B;MAAA,EACF;IAAA,GAACH,CAAA,CASDuH,mBAAA;MACE,QAAQ,KAAKnB,QAAA,OAAe,KAAKoB,SAAA,EACnC;IAAA,GAACxH,CAAA,CAEDwH,SAAA;MACE,YAAYjC,UACd;IAAA,GAACvF,CAAA,CAWDoG,QAAA;MAME,OAJEJ,IAAA,CAAKC,GAAA,CAAI,KAAKlB,aAAA,CAAcR,QAAA,IAAY,KAAKa,mBAAA,KAC5C,KAAKW,+BAAA,CAAgC,KAAKhB,aAAA,KACzC,KAAKC,8BAAA,IAC0B,MAA/B,KAAKa,aAAA,CAAciB,OAAA,CAEzB;IAAA,GAAC9G,CAAA,CAEDiH,YAAA,aAAa/G,CAAA;MACX,KAAK6E,aAAA,CAAcT,QAAA,GACjB,KAAKS,aAAA,CAAcT,QAAA,GAAWpE,CAAA,GAC9B,KAAKiF,cAAA,CAAeb,QAAA,IAAY,IAAIpE,CAAA,GACtC,KAAK6E,aAAA,CAAcR,QAAA,GACjB,KAAKQ,aAAA,CAAcR,QAAA,GAAWrE,CAAA,GAC9B,KAAKiF,cAAA,CAAeZ,QAAA,IAAY,IAAIrE,CAAA,CACxC;IAAA,GAACF,CAAA,CAEDyH,WAAA,aAAYvH,CAAA;MAEV,OADA,KAAK2E,SAAA,CAAU6C,IAAA,CAAKxH,CAAA,OAEtB;IAAA,GAACF,CAAA,CAED2H,kBAAA,aAAmBzH,CAAA;MAAa,IAAAF,CAAA,GAC9B;MAQA,OAJAO,MAAA,CAAOY,IAAA,CAAKjB,CAAA,EAAaqB,OAAA,CAAQ,UAAApB,CAAA;QAJb,IAAAE,CAAA;QAKlBH,CAAA,CAAYC,CAAA,KALME,CAAA,GAKaH,CAAA,CAAYC,CAAA;UAJ3CE,CAAA,CAAIU,KAAA,YAAAD,KAAA,CAAAJ,IAAA,CAAAY,SAAA,IACJtB,CAAA,CAAK4H,cAAA,CAAe1H,CAAA,CACtB;QAAA,EAGA;MAAA,IACA,KAAK2E,SAAA,CAAU6C,IAAA,CAAKxH,CAAA,OAEtB;IAAA,GAACF,CAAA,CAED4H,cAAA,aAAe1H,CAAA;MAEb,OADA4D,CAAA,CAAY,KAAKe,SAAA,EAAW3E,CAAA,GAE9B;IAAA,GAACA,CAAA;EAAA,CAlWD;ECnBI2H,CAAA,gBAAY;IAChB,SAAA3H,EAAYA,CAAA;MACV,KAAK4H,MAAA,GAAS5H,CAAA,IAAU,IAAI8D,CAAA,IAC5B,KAAK8D,MAAA,CAAO5D,YAAA,GAAe,MAE3B,KAAKW,SAAA,GAAY,IACjB,KAAKkD,cAAA,GAAiB,IACtB,KAAKC,kBAAA,GAAqB,IAC1B,KAAKC,OAAA,IAAU,GACf,KAAKC,eAAA,IAAmB,GACxB,KAAKC,eAAA,GAAkB,EACzB;IAAA;IAAC,IAAAnI,CAAA,GAAAE,CAAA,CAAAM,SAAA;IAuIA,OAvIAR,CAAA,CASDoI,YAAA,aAAalI,CAAA,EAASF,CAAA;MACpB,OAAW,KAACqI,sBAAA,CAAuB;QAAEvB,OAAA,EAAA5G,CAAA;QAAS8G,QAAA,EAAAhH;MAAA,EAChD;IAAA,GAACA,CAAA,CAKDqI,sBAAA,aAAuBnI,CAAA;MACrB,IAAMF,CAAA,GAAS,IAAI0E,CAAA,CAAO;MAG1B,OAFA,KAAK4D,cAAA,CAAetI,CAAA,GACpBA,CAAA,CAAO4F,eAAA,CAAgB1F,CAAA,GAChBF,CACT;IAAA,GAACA,CAAA,CAQDuI,SAAA;MACE,OAAO,KAAKN,OACd;IAAA,GAACjI,CAAA,CAUDsI,cAAA,aAAepI,CAAA;MACb,KAAKiI,eAAA,CAAgBjI,CAAA,CAAOuF,KAAA,MAAWvF,CACzC;IAAA,GAACF,CAAA,CASD2F,gBAAA,aAAiBzF,CAAA;MACf4D,CAAA,CAAY,KAAKiE,cAAA,EAAgB7H,CAAA,UAC1B,KAAKiI,eAAA,CAAgBjI,CAAA,CAAOuF,KAAA,GACrC;IAAA,GAACzF,CAAA,CAED+G,OAAA,aAAQ7G,CAAA,EAAMF,CAAA;MACZ,KADuB,IAAAG,CAAA,SAChB,KAAK6H,kBAAA,CAAmB1B,MAAA,GAAS,IACtC,KAAK0B,kBAAA,CAAmBQ,GAAA;MAU1B,KARA,KAAKT,cAAA,CAAe3G,MAAA,CAAO+F,OAAA,EAAS5F,OAAA,CAAQ,UAAAlB,CAAA;QACtCA,CAAA,CAAOkH,mBAAA,KACTlH,CAAA,CAAO0G,OAAA,CAAQ7G,CAAA,GAAO,KAAQF,CAAA,GAAY,OAE1CG,CAAA,CAAK6H,kBAAA,CAAmBN,IAAA,CAAKvH,CAAA,CAAK4H,cAAA,CAAe3E,OAAA,CAAQ/C,CAAA,EAE7D;MAAA,IAEO,KAAK2H,kBAAA,CAAmB1B,MAAA,GAAS,IAAG;QACzC,IAAMjG,CAAA,GAAM,KAAK2H,kBAAA,CAAmBQ,GAAA;QACpCnI,CAAA,IAAO,KAAK,KAAK0H,cAAA,CAAehE,MAAA,CAAO1D,CAAA,EAAK,EAC9C;MAAA;IACF,GAACL,CAAA,CAkBDmE,IAAA,aAAKjE,CAAA;MACH,IAAIF,CAAA;MAAA,CAC0B,MAA1B,KAAKkI,eAAA,KACP,KAAKA,eAAA,GAAkBhI,CAAA,GAAoB;MAE7C,IAAMC,CAAA,GAAiBD,CAAA,GAAoB,KAAKgI,eAAA;MAChD,KAAKA,eAAA,GAAkBhI,CAAA;MAEvB,IAAIG,CAAA,GAAI;QACFM,CAAA,GAAM,KAAKkE,SAAA,CAAUyB,MAAA;MAC3B,KAAKjG,CAAA,GAAI,GAAGA,CAAA,GAAIM,CAAA,EAAKN,CAAA,KACnBL,CAAA,GAAW,KAAK6E,SAAA,CAAUxE,CAAA,GACjBoI,iBAAA,IAAqBzI,CAAA,CAASyI,iBAAA,CAAkB;MAS3D,KANA,KAAK1B,OAAA,CAAQ7G,CAAA,EAAmBC,CAAA,GACG,MAA/B,KAAK4H,cAAA,CAAezB,MAAA,KACtB,KAAK2B,OAAA,IAAU,GACf,KAAKC,eAAA,IAAmB,IAGrB7H,CAAA,GAAI,GAAGA,CAAA,GAAIM,CAAA,EAAKN,CAAA,KACnBL,CAAA,GAAW,KAAK6E,SAAA,CAAUxE,CAAA,GACjBqI,gBAAA,IAAoB1I,CAAA,CAAS0I,gBAAA,CAAiB;MAGpD,KAAKT,OAAA,IACR,KAAKH,MAAA,CAAO7D,GAAA,EAEhB;IAAA,GAACjE,CAAA,CAMDqG,cAAA,aAAenG,CAAA;MACb,IAAMF,CAAA,GAAS,KAAKmI,eAAA,CAAgBjI,CAAA;MAAA,CACS,MAAzC,KAAK6H,cAAA,CAAe3E,OAAA,CAAQpD,CAAA,KAC9B,KAAK+H,cAAA,CAAeL,IAAA,CAAK1H,CAAA,GAEvB,KAAKuI,SAAA,OACP,KAAKN,OAAA,IAAU,GACf,KAAKH,MAAA,CAAO7D,GAAA,GAEhB;IAAA,GAAC/D,CAAA;EAAA,CAlJe;ECZZyI,CAAA,GAAsC,IAAId,CAAA;EAEnCe,CAAA,GAAwB,SAAAC,CAAC3I,CAAA;IACpC,IAAAF,CAAA,GAKIE,CAAA,CAJF4I,YAAA;MAAoC3I,CAAA,GAAiBH,CAAA,CAAjB+I,iBAAA;MACpC1I,CAAA,GAGEH,CAAA,CAHF8I,eAAA;MACArI,CAAA,GAEET,CAAA,CAFF+I,cAAA;MACAjI,CAAA,GACEd,CAAA,CADFkH,gBAAA;MAGI/F,CAAA,GAASsH,CAAA,CAAaP,YAAA,CANDpI,CAAA,CAAT4C,SAAA,EAAkB5C,CAAA,CAAP6C,OAAA;IAO7BxB,CAAA,CAAOuF,2BAAA,GAA8BzG,CAAA;IACrC,IAMMsB,CAAA,GAAgC;MACpC2F,gBAAA,EAAApG,CAAA;MACAsG,cAAA,EARqB,SAAAA,CAAA;QAErBjG,CAAA,CAAOqE,OAAA,IACP/E,CAAA,EACF;MAAA;MAKE+F,cAAA,EAAgBrG,CAAA,CAAgB;QAC9B6I,MAAA,EAAA7H,CAAA;QACA4H,cAAA,EAAAtI;MAAA;IAAA;IAKJ,OADAU,CAAA,CAAOoG,WAAA,CAAYhG,CAAA,GACZJ,CACT;EAAA;EAEa8H,CAAA,GAAe,SAAAf,CAAClI,CAAA;IAC3B,IAAMF,CAAA,GAAS4I,CAAA,CAAsB1I,CAAA;IAErC,OADAF,CAAA,CAAOkG,WAAA,CAAY,IACZlG,CACT;EAAA;EAOaoJ,CAAA,GAAyB,SAAAC,CACpCnJ,CAAA,EACAF,CAAA;IAEA,SAFA,MAAAA,CAAA,KAAAA,CAAA,GAAoC,KAE/BE,CAAA,IAAiBA,CAAA,CAAaoG,MAAA,EAAnC;MAIItG,CAAA,CAAcsJ,OAAA,IAChBpJ,CAAA,CAAaoJ,OAAA;MAGf,IAjB6BnJ,CAAA;QAiBvBE,CAAA,GAhBqB,oBADEF,CAAA,GAiBUH,CAAA,CAAcuJ,KAAA,IAhBT,MACpC,IAAGvD,IAAA,CAAKwD,GAAA,CAAIxD,IAAA,CAAKyD,GAAA,CAAkB,IAAdtJ,CAAA,EAAiB,IAAI;QAiB5CQ,CAAA,GAAgB,IAAIqF,IAAA,CAAKyD,GAAA,CAAIzD,IAAA,CAAKwD,GAAA,CAAItJ,CAAA,CAAaoG,MAAA,EAAQ,MAAM;QAEjEtF,CAAA,GAAmBd,CAAA,CACtBwJ,GAAA,CAAI,UAACxJ,CAAA,EAASF,CAAA;UACb,IAAMG,CAAA,GAAoBD,CAAA,CAAQ8I,eAAA;UAwBlC,OApBA9I,CAAA,CAAQ8I,eAAA,GAAkB,UAAA9I,CAAA;YACxB,IAAMmB,CAAA,GAAWlB,CAAA,CAAkBD,CAAA;YACnC,OAAO,UAAAA,CAAA;cACL,IAAIC,CAAA,GAAeD,CAAA,CAAO4F,eAAA;cAAA,CAE1B3F,CAAA,GACEA,CAAA,GAAe,MAAO,IAAIA,CAAA,GAAe,MAAO,IAAIA,CAAA,KAENQ,CAAA,IAE1CK,CAAA,CAAiBhB,CAAA,GAAI,MACvBgB,CAAA,CAAiBhB,CAAA,GAAI,GACnBgG,IAAA,CAAKyD,GAAA,CAAIzD,IAAA,CAAKwD,GAAA,CAAIrJ,CAAA,GAAeE,CAAA,EAAiB,IAAI,KAK5DgB,CAAA,CAASnB,CAAA,CACX;YAAA,CACF;UAAA,GACOA,CACT;QAAA,GACCwJ,GAAA,CAAI,UAAAxJ,CAAA;UACH,IAAMF,CAAA,GAAS4I,CAAA,CAAsB1I,CAAA;UACrC,IAAKF,CAAA,EAGL,OAAOA,CAAA,CAAOkG,WAAA,CAAYyD,IAAA,CAAK3J,CAAA,CACjC;QAAA,GACCoB,MAAA,CAAO+F,OAAA;MAENnG,CAAA,CAAiB,MACnBA,CAAA,CAAiB,GAAI,EAhDvB;IAAA;EAkDF;EC5Ea4I,CAAA,GAAgC,SAAAC,CAAC3J,CAAA;IAC5C,QAAC,GAAG,GAAG,GAAG,GAAG,IAAI,IAAIwJ,GAAA,CAAI,UAAA1J,CAAA;MAAA,OAASE,CAAA,CAAOF,CAAA,CAAM;IAAA,EAAC;EAAA;EAuFrC8J,CAAA,GAAiB,SAAAC,CAAH7J,CAAA;IAMzB,OALGA,CAAA,CAAH8J,GAAA,GAMQ3G,MAAA,CAAO4G,WAAA,IALT/J,CAAA,CAANgK,MAAA,GAMW,KALPhK,CAAA,CAAJiK,IAAA,GAMS9G,MAAA,CAAO+G,UAAA,IALXlK,CAAA,CAALmK,KAAA,GAMU,CAEZ;EAAA;AAOA,SAASC,EAAkBpK,CAAA;EAEzB,OADmBqK,IAAA,CAAKC,KAAA,CAAMtK,CAAA,CAAQuK,OAAA,CAAQC,UAAA,IAAc,KAE9D;AAAA;AAEA,IC3IaC,CAAA,GAAmB,SAAAC,CAC9B1K,CAAA,EACAF,CAAA;IAAiB,IAAAG,CAAA;IAAA,OACKkB,CAAA,CAAOnB,CAAA,IAAGC,CAAA,OAAKH,CAAA,CAAK,MAAKA,CAAA,CAAK,IAAEG,CAAA,EAAG;EAAA;EAE9C0K,CAAA,GAAiB,SAAAC,CAC5B5K,CAAA,EACAF,CAAA;IAEA,OACSW,CAAA,CADLX,CAAA,GAEA+K,QAAA,CAASC,gBAAA,CAAqB,MAAA/I,CAAA,GAA8B,OAAAjC,CAAA,WAG/CE,CAAA,CAAS8K,gBAAA,CAAgB,MAAKjJ,CAAA,GAAsB,KAEvE;EAAA;EACakJ,CAAA,GAAW,SAAAC,CACtBhL,CAAA;IAEA,OAAOA,CAAA,CAAgBwJ,GAAA,CACrB,UAACxJ,CAAA;MAAkB,OAAwC,CACzDA,CAAA,EACAA,CAAA,CAAMiL,qBAAA,GACP;IAAA,EAEL;EAAA;ECbIC,CAAA,IAAU;EAEDC,CAAA,GAAc,SAAAC,CAAA;IAAO,OAAAF,CAAA,IAAU,CAAK;EAAA;EAEpCG,CAAA,GAAa,SAAAC,CAAA;IAAA,OAAOJ,CAAA,IAAU,CAAI;EAAA;EAElCK,CAAA,GAAgB,SAAAC,CAAA;IAAH,OAASN,CAAO;EAAA;EA4C7BO,CAAA,GAAkB,SAAAC,CAAHvL,CAAA;IAeF,IAAAoB,CAAA,GAAApB,CAAA,CAdxBwL,oBAAA;MAAAjK,CAAA,QAAuB,MAAHH,CAAA,GAAG,KAAEA,CAAA;MAAAS,CAAA,GAAA7B,CAAA,CACzByL,oBAAA;MAAA3J,CAAA,QAAuB,MAAHD,CAAA,GAAG,CAAE,IAAAA,CAAA;MAAAqB,CAAA,GAAAlD,CAAA,CACzB0L,mCAAA;MAAAtI,CAAA,QAAsC,MAAHF,CAAA,GAAG,KAAEA,CAAA;MAAAK,CAAA,GAAAvD,CAAA,CACxC2L,aAAA;MAAAlI,CAAA,QAAa,MAAAF,CAAA,GAAG,CAAE,IAAAA,CAAA;MAClBI,CAAA,GAAW3D,CAAA,CAAX4L,WAAA;MACA7H,CAAA,GAAoB/D,CAAA,CAApB6L,oBAAA;MACA1H,CAAA,GAAMnE,CAAA,CAAN6I,MAAA;MACAzE,CAAA,GAAKpE,CAAA,CAAL8L,KAAA;MACAzH,CAAA,GAASrE,CAAA,CAAT+L,SAAA;MAASvE,CAAA,GAAAxH,CAAA,CACTgM,aAAA;MAAA1D,CAAA,QAAgB,MAAHd,CAAA,GAAG,KAAEA,CAAA;MAAAe,CAAA,GAAAvI,CAAA,CAClBiM,YAAA;MAAAjB,CAAA,cAAYzC,CAAA,GAAG,CAAE,IAAAA,CAAA;MACjB2C,CAAA,GAAuBlL,CAAA,CAAvBkM,uBAAA;MACAd,CAAA,GAAUpL,CAAA,CAAVmM,UAAA;MACAb,CAAA,GAAOtL,CAAA,CAAPoM,OAAA;IAEA,IAAKrB,CAAA,KACc/H,MAAA,CAAOqJ,UAAA,CAAW,oCACtBC,OAAA,EAAf;MACA,IChFyCC,CAAA;QDgFnCC,CAAA,GCzEgB5B,CAAA,CAASJ,CAAA,EAPU+B,CAAA,GDiFD;UACpCE,OAAA,EAAS9I,CAAA;UACToI,SAAA,EAAA1H;QAAA,GClFJoI,OAAA,EACSF,CAAA,CAATR,SAAA,GAKmE1C,GAAA,CACjE,UAAAxJ,CAAA;UAAE,IAAAF,CAAA,GAAKE,CAAA;YAAEC,CAAA,GAAQD,CAAA;YACTG,CAAA,GAAgBgD,MAAA,CAAO0J,gBAAA,CAAiB/M,CAAA;UAC9C,OAAO,CACLA,CAAA,CAAMyK,OAAA,CAAQuC,MAAA,EACd;YACEF,OAAA,EAAS9M,CAAA;YACTiN,IAAA,EAAM9M,CAAA;YACN+M,OAAA,EAASC,UAAA,CAAW9M,CAAA,CAAc6M,OAAA;YAClCE,SAAA,EAAW/M,CAAA,CAAc+M;UAAA,EAG/B;QAAA,GAGmBlM,MAAA,CAAOyJ,CAAA,EAAkB,CAAE;QDgE1C0C,CAAA,GA/CqB,UAAHnN,CAAA;UAML,IALnBF,CAAA,GAAWE,CAAA,CAAX+L,WAAA;YACA9L,CAAA,GAASD,CAAA,CAATkM,SAAA;UAKA,OAAIjM,CAAA,GA1BJ,UAACD,CAAA;YAAsB,iBAACF,CAAA;cACtB,OAAOW,CAAA,CACLoK,QAAA,CAASC,gBAAA,CAAgB,MACnB/I,CAAA,UAA8B/B,CAAA,GAAS,OAAKF,CAAA,EAGtD;YAAA,CAAC;UAAA,CAqBQ,CAA2BG,CAAA,IACzBH,CAAA,GArBuB,UAACE,CAAA;YACnC,IAAMF,CAAA,GAAgBgG,IAAA,CAAKsH,MAAA,GAASC,OAAA,CAAQ;YAG5C,OAFArN,CAAA,CAAYuK,OAAA,CAAQ+C,SAAA,GAAYxN,CAAA,YAExBG,CAAA;cACN,OAAOQ,CAAA,CACLT,CAAA,CAAY8K,gBAAA,wBACWhL,CAAA,GAAa,QAAMG,CAAA,EAG9C;YAAA,CACF;UAAA,CAWW,CAA4BH,CAAA,IAE5B;YAAA,OAAM,EAAE;UAAA,CAEnB;QAAA,CAiCyB,CAAqB;UAC1CiM,WAAA,EAAAjI,CAAA;UACAoI,SAAA,EAAA1H;QAAA;QAEI+I,CAAA,GAnCqB,UAACvN,CAAA;UAC5B,OAAQ,UAAAF,CAAA;YACN,OAAOE,CAAA,CAAc,MAAK6B,CAAA,GAA2B,OAAA/B,CAAA,SAAQ,EAC/D;UAAA,CACF;QAAA,CA+BqB,CAAqBqN,CAAA;QAElCK,CAAA,GAAY,SAAAC,CAACzN,CAAA;UAAU,OAC3BuD,CAAA,CAAoCvD,CAAA,KACpC2M,CAAA,CAAmC3M,CAAA,CAAG;QAAA;QAElC0N,CAAA,GAAerN,MAAA,CAAOY,IAAA,CAAKsC,CAAA,EAC9BoK,MAAA,CAAOtN,MAAA,CAAOY,IAAA,CAAK0L,CAAA,GACnBzL,MAAA,CAAO,UAAAlB,CAAA;UAAE,QAAKwN,CAAA,CAAUxN,CAAA,CAAG;QAAA;QAExB4N,CAAA,GAAyB;UAC7B9B,aAAA,EAAAlI,CAAA;UACAiK,UAAA,EAAAN,CAAA;UACA1B,mCAAA,EAAAtI,CAAA;UACAuK,kCAAA,EAAAnB,CAAA;UACAf,oBAAA,EAAA3J,CAAA;UACAmK,YAAA,EAAAjB;QAAA;QAOF4C,CAAA,GErH+B,UAAH/N,CAAA;UAAA,IAyCxBF,CAAA;YAxCJG,CAAA,GAAYD,CAAA,CAAZgO,YAAA;YACA7N,CAAA,GAAaH,CAAA,CAAb8L,aAAA;YACArL,CAAA,GAAUT,CAAA,CAAV6N,UAAA;YACA/M,CAAA,GAAmCd,CAAA,CAAnC6L,mCAAA;YACA1K,CAAA,GAAkCnB,CAAA,CAAlC8N,kCAAA;YACAvM,CAAA,GAAoBvB,CAAA,CAApB4L,oBAAA;YACApK,CAAA,GAAYxB,CAAA,CAAZoM,YAAA;YAKM1K,CAAA,GAHqBzB,CAAA,CAAaiB,MAAA,CACtC,UAAAlB,CAAA;cAAM,OAAAmB,CAAA,CAAmCnB,CAAA,CAAG;YAAA,GAEQkB,MAAA,CACpD,UAAAlB,CAAA;cAAA,OAAMG,CAAA,CAAcH,CAAA,KAAOG,CAAA,CAAcH,CAAA,EAAIiO,QAAQ;YAAA;YAGjDpM,CAAA,GAA4B5B,CAAA,CAAaiB,MAAA,CAC7C,UAAAlB,CAAA;cACE,OAAAc,CAAA,CAAoCd,CAAA,KACpCG,CAAA,CAAcH,CAAA,KACdG,CAAA,CAAcH,CAAA,EAAIkO,MAAM;YAAA;YAuBtBpM,CAAA,GAAiC,IAAIqM,OAAA,CAAQ,UAAAnO,CAAA;cACjDF,CAAA,GAAiBE,CACnB;YAAA;YAEM+B,CAAA,GAAkC;YACpCC,CAAA,GAAsB;YAEpBC,CAAA,GAAkBJ,CAAA,CAA0B2H,GAAA,CAAI,UAACxJ,CAAA,EAAIC,CAAA;cACzD,IAAAQ,CAAA,GAMIK,CAAA,CAAoCd,CAAA,EALtCoO,wBAAA;gBACEjN,CAAA,GAAOV,CAAA,CAAPmM,OAAA;gBACAlL,CAAA,GAAMjB,CAAA,CAAN4N,MAAA;gBAAMxM,CAAA,GAAApB,CAAA,CACN6N,aAAA;gBAAiBxM,CAAA,GAAGD,CAAA,CAAHiI,GAAA;gBAAK7H,CAAA,GAAIJ,CAAA,CAAJoI,IAAA;gBAAMzH,CAAA,GAAKX,CAAA,CAAL0M,KAAA;gBAAOvL,CAAA,GAAMnB,CAAA,CAAN2M,MAAA;cAIG,aAAtC3B,gBAAA,CAAiBnL,CAAA,EAAQ0C,QAAA,KAC3B1C,CAAA,CAAO+M,KAAA,CAAMrK,QAAA,GAAW,aAE1BjD,CAAA,CAAQsN,KAAA,CAAMvB,SAAA,GAAY,4BAC1B/L,CAAA,CAAQsN,KAAA,CAAMrK,QAAA,GAAW,YACzBjD,CAAA,CAAQsN,KAAA,CAAM3E,GAAA,GAAMhI,CAAA,GAAM,MAC1BX,CAAA,CAAQsN,KAAA,CAAMxE,IAAA,GAAOhI,CAAA,GAAO,MAE5Bd,CAAA,CAAQsN,KAAA,CAAMD,MAAA,GAASxL,CAAA,GAAS,MAChC7B,CAAA,CAAQsN,KAAA,CAAMF,KAAA,GAAQ/L,CAAA,GAAQ;cAC9B,IAAIa,CAAA,GAA2CtB,CAAA,CAAeb,MAAA,CAC5D,UAAAlB,CAAA;gBAAC,OAAIA,CAAA,CAAE,OAAO0B,CAAM;cAAA,GACpB;cACG2B,CAAA,KACHA,CAAA,GAAgB,CAAC3B,CAAA,EAAQmJ,QAAA,CAAS6D,sBAAA,KAClC3M,CAAA,CAAeyF,IAAA,CAAKnE,CAAA,IAEtBA,CAAA,CAAc,GAAGsL,WAAA,CAAYxN,CAAA,GAE7Ba,CAAA,IAAuB;cAEvB,IAAMuB,CAAA,GAAO,SAAAqL,CAAA;gBACX;kBACElN,CAAA,CAAOmN,WAAA,CAAY1N,CAAA,CACrB;gBAAA,CAAE,QAAOnB,CAAA,GAAc,CAEtB;kBAE6B,MAD5BgC,CAAA,IAAuB,MAErBlC,CAAA,EAEJ;gBAAA;cACF;cAGA,OADAyB,CAAA,CAAqBvB,CAAA,IAAM;gBAAE4O,IAAA,EAAArL;cAAA,GACtB;gBAAA,OAAMpD,CAAA,CAAcH,CAAA,EAAIkO,MAAA,CAAQ/M,CAAA,EAASlB,CAAA,EAAGsD,CAAA,EAAM/B,CAAA,CAAa;cAAA,CACxE;YAAA;UAiBA,OAbAO,CAAA,CAAeV,OAAA,CAAQ,UAAArB,CAAA;YACrBA,CAAA,CAAE,GAAG2O,WAAA,CAAY3O,CAAA,CAAE,GACrB;UAAA,IAEKiC,CAAA,CAAgBmE,MAAA,IACnBtG,CAAA,IAQK;YACLgP,oBAAA,EA1F2B,SAAAA,CAAA;cAC3BpN,CAAA,CAA2BL,OAAA,CAAQ,UAAArB,CAAA;gBACjC,IAAMF,CAAA,GAAUW,CAAA,CAAWT,CAAA;gBACvBF,CAAA,KACFA,CAAA,CAAQ2O,KAAA,CAAMzB,OAAA,GAAU,IAE5B;cAAA,EACF;YAAA;YAoFE+B,uBAAA,EAlF8B,SAAAA,CAAA;cAC9BrN,CAAA,CAA2BL,OAAA,CAAQ,UAACrB,CAAA,EAAIF,CAAA;gBACtC,IAAMG,CAAA,GAAUQ,CAAA,CAAWT,CAAA;gBACvBC,CAAA,IACFE,CAAA,CAAcH,CAAA,EAAIiO,QAAA,CAAUhO,CAAA,EAASH,CAAA,EAAG0B,CAAA,CAE5C;cAAA,EACF;YAAA;YA4EEwN,sBAAA,EAR6B,SAAAA,CAAA;cAE7B,OADA/M,CAAA,CAAgBZ,OAAA,CAAQ,UAAArB,CAAA;gBAAK,OAAAA,CAAA,EAAG;cAAA,IACzB8B,CACT;YAAA;UAAA,CAOF;QAAA,CFIM,CARiCX,CAAA,CAAO,CAAE,GAAEyM,CAAA,EAAU;UACxDI,YAAA,EAAAN;QAAA;QAIAuB,CAAA,GAAoBlB,CAAA,CAApBe,oBAAA;QACAI,CAAA,GAAuBnB,CAAA,CAAvBgB,uBAAA;QACAI,CAAA,GAAsBpB,CAAA,CAAtBiB,sBAAA;QAKII,CAAA,GAAyDjO,CAAA,CAC7D,IACAyM,CAAA,EACA;UACE7B,WAAA,EAAAjI,CAAA;UACAuL,UAAA,EAP2B3N,CAAA,CAAqBR,MAAA,CAAOsM,CAAA;UAQvDxB,oBAAA,EAAA9H,CAAA;UACA8E,MAAA,EAAA1E,CAAA;UACA2H,KAAA,EAAA1H,CAAA;UACA4H,aAAA,EAAA1D,CAAA;UACA6G,cAAA,EAAAnC,CAAA;UACAb,UAAA,EAAAf;QAAA;MAGAE,CAAA,IAASA,CAAA,CAAQ3H,CAAA,EAAaqH,CAAA;MAIlC,IAAMoE,EAAA,GFFR,UAAepP,CAAA;QACb,IAgBIoB,CAAA;UAhBJG,CAAA,GAAUvB,CAAA,CAAVkP,UAAA;UACAxN,CAAA,GAAa1B,CAAA,CAAb2L,aAAA;UACA/J,CAAA,GAAoB5B,CAAA,CAApByL,oBAAA;UACA5J,CAAA,GAAmC7B,CAAA,CAAnC0L,mCAAA;UACA5J,CAAA,GAAkC9B,CAAA,CAAlC2N,kCAAA;UACAzK,CAAA,GAAoBlD,CAAA,CAApB6L,oBAAA;UACAzI,CAAA,GAAMpD,CAAA,CAAN6I,MAAA;UACAtF,CAAA,GAAUvD,CAAA,CAAV0N,UAAA;UACAjK,CAAA,GAAKzD,CAAA,CAAL8L,KAAA;UAAKnI,CAAA,GAAA3D,CAAA,CACLgM,aAAA;UAAAjI,CAAA,QAAgB,MAAHJ,CAAA,GAAG,KAAEA,CAAA;UAAAQ,CAAA,GAAAnE,CAAA,CAClBiM,YAAA;UAAA7H,CAAA,QAAe,MAAHD,CAAA,GAAG,KAAEA,CAAA;UACjBE,CAAA,GAAUrE,CAAA,CAAVmM,UAAA;UACA3E,CAAA,GAAWxH,CAAA,CAAX4L,WAAA;UAMMtD,CAAA,GAA4C,IAAI0F,OAAA,CAAQ,UAAAnO,CAAA;YAC5DuB,CAAA,GAAiBvB,CACnB;UAAA;QAKA,IAHIwE,CAAA,IACFiE,CAAA,CAAqB+G,IAAA,CAAK;UAAA,OAAMhL,CAAA,CAAWmD,CAAA,EAAapD,CAAA,CAAa;QAAA,KAElE7C,CAAA,CAAW0E,MAAA,EACd;UAEE,OADA7E,CAAA,CAAgB,KACTkH,CACT;QAAA;QAGF,IAAMC,CAAA,GAAoC;UAEpC+B,CAAA,GAA4B/G,CAAA,CAAWhC,CAAA,CAAW;UAElDiJ,CAAA,GAAOF,CAAA,GACTA,CAAA,CAAagF,aAAA,CAAeC,aAAA,CAAc,UAC1C7E,QAAA,CAAS6E,aAAA,CAAc;QAWF5O,CAAA,CAA0BY,CAAA;QAYnD,IAAMqJ,CAAA,GAA+BrJ,CAAA,CAIlC8H,GAAA,CAAI,UAAArJ,CAAA;UACH,IAAMW,CAAA,GAAWkB,CAAA,CAAoC7B,CAAA,EAAI4M,IAAA;YACnDrL,CAAA,GAAcO,CAAA,CAAmC9B,CAAA,EAAI4M,IAAA;YACrDrJ,CAAA,GAAc1B,CAAA,CAAoC7B,CAAA,EAAI6M,OAAA;YACtDpJ,CAAA,GAAiB3B,CAAA,CAAmC9B,CAAA,EAAI6M,OAAA;YACxDlJ,CAAA,GAAqBpC,CAAA,CAAY6M,KAAA,GAAQ,KAAK7M,CAAA,CAAY8M,MAAA,GAAS;YACnEtK,CAAA,GAAUjC,CAAA,CAAmC9B,CAAA,EAAIyM,OAAA;UAGvD,KAAKhD,CAAA,CAAe9I,CAAA,MAAc8I,CAAA,CAAelI,CAAA,GAC/C,QAAO;UAIT,KAAKwC,CAAA,EACH;UAGF,INpMsBI,CAAA;YAG8CE,CAAA;YADxEmD,CAAA;YMkMUc,CAAA,GAAa2B,CAAA,CAAkBlG,CAAA;YAE/B+E,CAAA,INpMVtB,CAAA,IACwEnD,CAAA,QAAN,OAHxCF,CAAA,GMsMe;cACnCqL,aAAA,EAAepM,CAAA;cACfqM,aAAA,EAAenH,CAAA,CAAWO;YAAA,KNrMkC,CAAE,IAAA1E,CAAA,EADpEsL,aAAA,EAEOzO,CAAA,CACL,IACAqB,CAAA,CAAcC,QAAA,EACdO,CAAA,CANWwB,CAAA,CAAbmL,aAAA,GAOE3M,CAAA,CAAgB2E,CAAA;YMmMRuB,CAAA,IACmB,MAAvBT,CAAA,CAAWoH,OAAA,GAAmB,YAAYpH,CAAA,CAAWoH,OAAA;YAEjDpF,CAAA,GAAW;cACfmC,OAAA,EAAA1I,CAAA;cACA4L,EAAA,EAAA3P,CAAA;cACA0P,OAAA,EAAA3G,CAAA;cACAN,YAAA,EAAAK;YAAA;UAGF,IAAIpH,CAAA,CAAc1B,CAAA,KAAO0B,CAAA,CAAc1B,CAAA,EAAI4P,UAAA,KACflO,CAAA,CAAc1B,CAAA,EAAI4P,UAAA,CAC1CxL,CAAA,CAAayL,QAAA,EACbzL,CAAA,CAAa0L,OAAA,GAGb,QAAO;UAOX,IAGM/E,CAAA,GAHuBpF,IAAA,CAAKC,GAAA,CAAIjF,CAAA,CAASmJ,IAAA,GAAOvI,CAAA,CAAYuI,IAAA,IACrCnE,IAAA,CAAKC,GAAA,CAAIjF,CAAA,CAASgJ,GAAA,GAAMpI,CAAA,CAAYoI,GAAA;YAO3DqB,CAAA,GAHmBrF,IAAA,CAAKC,GAAA,CAAIjF,CAAA,CAASyN,KAAA,GAAQ7M,CAAA,CAAY6M,KAAA,IACtCzI,IAAA,CAAKC,GAAA,CAAIjF,CAAA,CAAS0N,MAAA,GAAS9M,CAAA,CAAY8M,MAAA;YAI1DnD,CAAA,GAAoBvF,IAAA,CAAKC,GAAA,CAAInC,CAAA,GAAiBF,CAAA;UASpD,IAFuB,MAApB5C,CAAA,CAAS0N,MAAA,IAAuC,MAAvB9M,CAAA,CAAY8M,MAAA,IAClB,MAAnB1N,CAAA,CAASyN,KAAA,IAAqC,MAAtB7M,CAAA,CAAY6M,KAAA,IANrCrD,CAAA,GAAsB,MACtBC,CAAA,GAAkB,MAClBE,CAAA,GAAoB,KAMpB;UAGF,IAAME,CAAA,GAAmBvL,CAAA,CAASsK,KAAA,CAChCrI,CAAA,CAAmC9B,CAAA,EAAI+M,SAAA;YAGnCzB,CAAA,GAAuB;cAAEyE,MAAA,EAAQ3E;YAAA;YAEjCmB,CAAA,GAAyB;cAAEwD,MAAA,EAAQ;YAAA;YACnCvD,CAAA,GAAkB,CAACpB,CAAA;UAGrB9C,CAAA,CAAW0H,SAAA,KACbxD,CAAA,CAAgBnF,IAAA,CACdxH,CAAA,CAASoQ,UAAA,CAAWtP,CAAA,CAASmJ,IAAA,GAAOvI,CAAA,CAAYuI,IAAA,IAElD0C,CAAA,CAAgBnF,IAAA,CACdxH,CAAA,CAASqQ,UAAA,CAAWvP,CAAA,CAASgJ,GAAA,GAAMpI,CAAA,CAAYoI,GAAA,KAI/CrB,CAAA,CAAW6H,KAAA,KACb3D,CAAA,CAAgBnF,IAAA,CACdxH,CAAA,CAASuQ,MAAA,CACPzK,IAAA,CAAKyD,GAAA,CAAIzI,CAAA,CAASyN,KAAA,EAAO,KAAKzI,IAAA,CAAKyD,GAAA,CAAI7H,CAAA,CAAY6M,KAAA,EAAO,MAG9D5B,CAAA,CAAgBnF,IAAA,CACdxH,CAAA,CAASwQ,MAAA,CACP1K,IAAA,CAAKyD,GAAA,CAAIzI,CAAA,CAAS0N,MAAA,EAAQ,KAAK1I,IAAA,CAAKyD,GAAA,CAAI7H,CAAA,CAAY8M,MAAA,EAAQ,OAK9D/F,CAAA,CAAWuE,OAAA,KACbN,CAAA,CAASM,OAAA,GAAUtJ,CAAA,EACnB+H,CAAA,CAAOuB,OAAA,GAAUpJ,CAAA;UAGnB,IAAIuJ,CAAA,GAAqC;UAEzC,KACGtL,CAAA,CAAc1B,CAAA,MACd0B,CAAA,CAAc1B,CAAA,EAAIsQ,YAAA,IACnB5O,CAAA,CAAc1B,CAAA,EAAIsQ,YAAA,CAChBlM,CAAA,CAAayL,QAAA,EACbzL,CAAA,CAAa0L,OAAA,GAEf;YACA,IAAM1C,CAAA,GAlMc,UAACvN,CAAA,EAAsBF,CAAA;cAAU,OAC3DW,CAAA,CACET,CAAA,CAAQ8K,gBAAA,CAAqB,MAAAhJ,CAAA,UAAmChC,CAAA,GAAE,MACnE;YAAA,CA+LmC,CAAoBoE,CAAA,EAAS/D,CAAA;YAC3DgN,CAAA,GAAmBI,CAAA,CAAsB/D,GAAA,CAAI,UAAAxJ,CAAA;cAAC,OAAI,CAChDA,CAAA,EACAoK,CAAA,CAAkBpK,CAAA,EACnB;YAAA,EACH;UAAA;UAEA0M,CAAA,CAASwD,MAAA,GAASxG,CAAA,CAChBiD,CAAA,CAAgB3L,MAAA,CAAOhB,CAAA,CAAS0Q,QAAA,IAGlCjF,CAAA,CAAOyE,MAAA,GAASxG,CAAA,CAA8B+B,CAAA,CAAOyE,MAAA;UAErD,IAMI1C,CAAA;YANEE,CAAA,GA5QV,UADgC1N,CAAA;cAAA,IAE9BC,CAAA,GAAOD,CAAA,CAAP4M,OAAA;gBACAzM,CAAA,GAAgBH,CAAA,CAAhB2Q,gBAAA;gBACAlQ,CAAA,GAAIT,CAAA,CAAJ4Q,IAAA;cAAA,OAMF,UAAA5Q,CAAA;gBAQK,IAPHc,CAAA,GAAMd,CAAA,CAANkQ,MAAA;kBACA/O,CAAA,GAAOnB,CAAA,CAAPgN,OAAA;kBACAzL,CAAA,GAAYvB,CAAA,CAAZ6Q,YAAA;gBAeA,IATI/Q,CAAA,CAASqB,CAAA,MACXlB,CAAA,CAAQwO,KAAA,CAAMzB,OAAA,GAAU7L,CAAA,GAAU,KAGhCI,CAAA,KACFtB,CAAA,CAAQwO,KAAA,CAAMqC,SAAA,GAAY,OAC1B7Q,CAAA,CAAQwO,KAAA,CAAMsC,QAAA,GAAW,QAGtBjQ,CAAA,EAAL;kBAIA,IAAMU,CAAA,GArEkC,UAACxB,CAAA;oBACjC,mBAAAA,CAAA,CAAOgR,IAAA,CAAK;kBAAA,CAoEI,CAA6BlQ,CAAA;kBAKrDb,CAAA,CAAQwO,KAAA,CAAMvB,SAAA,GAAY1L,CAAA,EAEtBrB,CAAA,IAzEmC,UAAHH,CAAA;oBACtC,IACAF,CAAA,GAAME,CAAA,CAANkQ,MAAA;sBACAjQ,CAAA,GAAID,CAAA,CAAJ4Q,IAAA;oBAFgB5Q,CAAA,CAAhB2Q,gBAAA,CAQiBtP,OAAA,CAAQ,UAAArB,CAAA;sBAAA,IAAEG,CAAA,GAAKH,CAAA;wBAAES,CAAA,GAAeT,CAAA;sBAC/C,IAAKC,CAAA,CAAKgR,QAAA,CAAS9Q,CAAA,GAAnB;wBAGA,IAAMW,CAAA,GAAShB,CAAA,CAAO;0BAChBqB,CAAA,GAASrB,CAAA,CAAO;0BAEhByB,CAAA,GAAazB,CAAA,CAAO;0BAEpB0B,CAAA,GAAc;4BAAE4O,UAAA,EAAY;4BAAGC,UAAA,EAAY;4BAAGE,MAAA,EAAQ;4BAAGC,MAAA,EAAQ;0BAAA;0BACnE9O,CAAA,GAAkB;wBAClBjB,CAAA,CAAgB0P,SAAA,KAClB3O,CAAA,CAAY4O,UAAA,IANKtQ,CAAA,CAAO,KAMegB,CAAA,EACvCU,CAAA,CAAY6O,UAAA,IAAc9O,CAAA,GAAaJ,CAAA,EACvCO,CAAA,IAAgC,eAAAF,CAAA,CAAY4O,UAAA,YAAiB5O,CAAA,CAAY6O,UAAA,GAAU,QAEjF5P,CAAA,CAAgB6P,KAAA,KAClB9O,CAAA,CAAY+O,MAAA,GAAS,IAAIzP,CAAA,EACzBU,CAAA,CAAYgP,MAAA,GAAS,IAAIrP,CAAA,EACzBO,CAAA,IAAe,YAAcF,CAAA,CAAY+O,MAAA,GAAW,OAAA/O,CAAA,CAAYgP,MAAA,GAAM,MAExErQ,CAAA,CAAMsO,KAAA,CAAMvB,SAAA,GAAYxL,CAlBxB;sBAAA;oBAmBF,EACF;kBAAA,CA0CM,CAA4B;oBAC1BiP,gBAAA,EAAAxQ,CAAA;oBACA+P,MAAA,EAAApP,CAAA;oBACA8P,IAAA,EAAAnQ;kBAAA,EAbJ;gBAAA;cAgBF,CAAC;YAAA,CA+NuB,CAAsB;cACxCmM,OAAA,EAAA1I,CAAA;cACAyM,gBAAA,EAAAxD,CAAA;cACAyD,IAAA,EAAAjG;YAAA;UAIF,IAAI9I,CAAA,CAAc1B,CAAA,KAAO0B,CAAA,CAAc1B,CAAA,EAAImM,UAAA,EAAY;YAErD,IAAMsB,CAAA,GAAmB/L,CAAA,CAAc1B,CAAA,EAAImM,UAAA;YAC3CkB,CAAA,GAAa,SAAAlB,CAAA;cAAM,OAAAsB,CAAA,CAAkB1J,CAAA,EAASK,CAAA,CAAa;YAAA,CAC7D;UAAA;UAKA,IAyBMwJ,CAAA,GACJjO,CAAA,CAAS4M,CAAA,CAASM,OAAA,KAClBlN,CAAA,CAAS2L,CAAA,CAAOuB,OAAA,KAChBN,CAAA,CAASM,OAAA,KAAYvB,CAAA,CAAOuB,OAAA;YAE1BiC,CAAA,IAAgB;UAsEpB,OAAO9N,CAAA,CAAO,CAAE,GAAEsJ,CAAA,EAAU;YAC1BoF,OAAA,EAAA3G,CAAA;YACAN,YAAA,EAAAK,CAAA;YACAH,eAAA,EAvEuC,SAAAA,CAApB9I,CAAA;cAAmD,IAA5BF,CAAA,GAAME,CAAA,CAANgJ,MAAA;gBAAQ/I,CAAA,GAAcD,CAAA,CAAd+I,cAAA;cAsClD,OArCAhH,CAAA,CAAqB5B,CAAA,IAAM;gBACzBqF,OAAA,EAAS1F,CAAA,CAAO0F,OAAA,CAAQiE,IAAA,CAAK3J,CAAA;gBAC7BiJ,cAAA,EAAA9I;cAAA,GAEyB,UAAAD,CAAA;gBACrB6B,CAAA,CAAc1B,CAAA,KAAO0B,CAAA,CAAc1B,CAAA,EAAIqG,cAAA,IACzC3E,CAAA,CAAc1B,CAAA,EAAIqG,cAAA,CAAgBxG,CAAA,CAAO4F,eAAA,KAGtCqJ,CAAA,KACHA,CAAA,IAAgB,GACZpN,CAAA,CAAc1B,CAAA,KAAO0B,CAAA,CAAc1B,CAAA,EAAIoM,OAAA,IACzC1K,CAAA,CAAc1B,CAAA,EAAIoM,OAAA,CAASrI,CAAA,EAASK,CAAA;gBAIxC,IAAMzE,CAAA,GAAeE,CAAA,CAAO4F,eAAA;gBAC5B,IAAK+E,CAAA,CAAKsG,QAAA,CAAS/M,CAAA,GAAnB;kBAKA,IAAMjE,CAAA,GAAqB;oBAAEiQ,MAAA,EAAQ;kBAAA;kBAErCjQ,CAAA,CAAKiQ,MAAA,GAASxD,CAAA,CAASwD,MAAA,CAAO1G,GAAA,CAAI,UAACxJ,CAAA,EAASC,CAAA;oBAAK,OAC/CuB,CAAA,CAAUxB,CAAA,EAASyL,CAAA,CAAOyE,MAAA,CAAOjQ,CAAA,GAAQH,CAAA,CAAa;kBAAA,IAGpDiO,CAAA,KACF9N,CAAA,CAAK+M,OAAA,GAAUxL,CAAA,CACbkL,CAAA,CAASM,OAAA,EACTvB,CAAA,CAAOuB,OAAA,EACPlN,CAAA,IAGJ4N,CAAA,CAAYzN,CAAA,CAfZ;gBAAA,OAFED,CAAA,CAAOwF,OAAA,EAkBX;cAAA,CAEF;YAAA;YAiCE0L,cAAA,EA/BqC,SAAAA,CAAA;cAErCxD,CAAA,CAAY;gBACVwC,MAAA,EAAQxD,CAAA,CAASwD,MAAA;gBACjBlD,OAAA,EAASe,CAAA,GAAiBrB,CAAA,CAASM,OAAA,QAAU;gBAC7C6D,YAAA,EAAc/M;cAAA,IAGZjC,CAAA,CAAc1B,CAAA,KAAO0B,CAAA,CAAc1B,CAAA,EAAIgR,gBAAA,IACzCtP,CAAA,CAAc1B,CAAA,EAAIgR,gBAAA,CAAkBjN,CAAA,EAASK,CAAA,GAG3CkE,CAAA,CAAW2I,eAAA,GACblN,CAAA,CAAQuK,KAAA,CAAM2C,eAAA,GAAkB3I,CAAA,CAAW2I,eAAA,GAClC/N,CAAA,KACTa,CAAA,CAAQuK,KAAA,CAAM2C,eAAA,GAAkB,QAGlCjE,CAAA,CAAiB9L,OAAA,CAAQ,UAAArB,CAAA;gBAA6B,IAA3BF,CAAA,GAAKE,CAAA;kBAAEC,CAAA,GAAeD,CAAA,CAC/C;gBAAIC,CAAA,CAAgBmR,eAAA,GAClBtR,CAAA,CAAM2O,KAAA,CAAM2C,eAAA,GAAkBnR,CAAA,CAAgBmR,eAAA,GACrC/N,CAAA,KACTvD,CAAA,CAAM2O,KAAA,CAAM2C,eAAA,GAAkB,MAElC;cAAA,EACF;YAAA;YAOErI,cAAA,EAzGqB,SAAAA,CAAC/I,CAAA;cAAA,OACf+B,CAAA,CAAqB5B,CAAA,GACxBF,CAAA,CAAWuN,CAAA,KACbA,CAAA,IAGFtJ,CAAA,CAAQuK,KAAA,CAAMvB,SAAA,GAAY,IAC1BC,CAAA,CAAiB9L,OAAA,CAAQ,UAAArB,CAAA;gBAASA,CAAA,IACxByO,KAAA,CAAMvB,SAAA,GAAY,EAC5B;cAAA,IACIpJ,CAAA,IAAsBI,CAAA,KACxBA,CAAA,CAAQuK,KAAA,CAAMqC,SAAA,GAAY,IAC1B5M,CAAA,CAAQuK,KAAA,CAAMsC,QAAA,GAAW,KAEvB/Q,CAAA,KAEJ0I,CAAA,CAAsBlB,IAAA,CAAKrH,CAAA,GAEvBuI,CAAA,CAAsBtC,MAAA,IAAU2E,CAAA,CAAc3E,MAAA,IAGhD7E,CAAA,CAAemH,CAAA,EAEnB;YAAA;YAmFE2I,UAAA,EAAY5I,CAAA,CAAW4I;UAAA,EAE3B;QAAA,GAECnQ,MAAA,CAAO+F,OAAA;QAIV,IAFA8D,CAAA,CAAc1J,OAAA,CAAQ,UAAArB,CAAA;UAAA,QAAwB,GAAPA,CAAA,CAAdkR,cAAA,GAAqC;QAAA,IAE1DtN,CAAA,EACF,OAAO,aACT;QAEA,IAGMsH,CAAA,GAAcH,CAAA,CAAc7J,MAAA,CAChC,UAAAlB,CAAA;YAAC,OAAIA,CAAA,CAAEqR,UAAA,KAJiBvR,CAAA,GAIcE,CAAA,CAAEqR,UAAA,EAHxCtG,CAAA,CAAc7J,MAAA,CAAO,UAAAlB,CAAA;cAAK,OAAAA,CAAA,CAAE8P,EAAA,KAAOhQ,CAAM;YAAA,GAAEsG,MAAA;YADpB,IAACtG,CAI2B;UAAA;UAI/CqL,CAAA,GAAoB;UAEpBE,CAAA,GAAqB;UAErBE,CAAA,GAAqB;QAE3BL,CAAA,CAAY7J,OAAA,CAAQ,UAAArB,CAAA;UACdA,CAAA,CAAK6P,OAAA,IACPtE,CAAA,CAAmBvL,CAAA,CAAK6P,OAAA,KAAW,GAC/BxE,CAAA,CAAmBrL,CAAA,CAAKqR,UAAA,IAC1BhG,CAAA,CAAmBrL,CAAA,CAAKqR,UAAA,EAAa7J,IAAA,CAAKxH,CAAA,CAAK6P,OAAA,IAC5CxE,CAAA,CAAmBrL,CAAA,CAAKqR,UAAA,IAAe,CAACrR,CAAA,CAAK6P,OAAA,KAE9C1E,CAAA,CAAkBnL,CAAA,CAAKqR,UAAA,IACzBlG,CAAA,CAAkBnL,CAAA,CAAKqR,UAAA,EAAa7J,IAAA,CAAKxH,CAAA,IACtCmL,CAAA,CAAkBnL,CAAA,CAAKqR,UAAA,IAAe,CAACrR,CAAA,CAEhD;QAAA;QAEA,IAAMyL,CAAA,GAAcV,CAAA,CACjB7J,MAAA,CAAO,UAAAlB,CAAA;YAAY,OAAAA,CAAA,CAAS6P,OAAO;UAAA,GACnC7O,MAAA,CAAO,UAAChB,CAAA,EAAKF,CAAA;YAMZ,OALIE,CAAA,CAAIF,CAAA,CAAK+P,OAAA,IACX7P,CAAA,CAAIF,CAAA,CAAK+P,OAAA,EAASrI,IAAA,CAAK1H,CAAA,IAEvBE,CAAA,CAAIF,CAAA,CAAK+P,OAAA,IAAW,CAAC/P,CAAA,GAEhBE,CACT;UAAA,GAAG;UAEC0M,CAAA,GAAgB3B,CAAA,CAAc7J,MAAA,CAAO,UAAAlB,CAAA;YAAK,QAA4B,MAA5BkL,CAAA,CAAYhI,OAAA,CAAQlD,CAAA,CAAS;UAAA;QAyB7E,OAvBA0M,CAAA,CAAcrL,OAAA,CAAQ,UAAArB,CAAA;UACpBA,CAAA,CAASkH,gBAAA,GAAmB;YACtBiE,CAAA,CAAkBnL,CAAA,CAAS8P,EAAA,KAC7B3E,CAAA,CAAkBnL,CAAA,CAAS8P,EAAA,EAAIzO,OAAA,CAAQ4H,CAAA,GAErCoC,CAAA,CAAmBrL,CAAA,CAAS8P,EAAA,KACJzP,MAAA,CAAOY,IAAA,CAC/BoK,CAAA,CAAmBrL,CAAA,CAAS8P,EAAA,EAAI9O,MAAA,CAC9B,UAAChB,CAAA,EAAsBF,CAAA;cAAY,IAAAG,CAAA;cACjC,OAAAkB,CAAA,CAAOnB,CAAA,IAAGC,CAAA,OAAKH,CAAA,KAAO,GAAIG,CAAA,EAAG;YAAA,GAC/B,CAAE,IAGYoB,OAAA,CAAQ,UAACrB,CAAA;cACzBkJ,CAAA,CACEuC,CAAA,CAAYzL,CAAA,GACZkE,CAAA,CAAclE,CAAA,EAElB;YAAA,EAEJ;UAAA,CACF;QAAA,IAEO;UAkBL,OAfK+K,CAAA,CAAc3E,MAAA,IACjB7E,CAAA,CAAe,KAGjBmL,CAAA,CACGxL,MAAA,CAAO,UAAAlB,CAAA;YACN,QAAQA,CAAA,CAAS6P,OACnB;UAAA,GACCxO,OAAA,CAAQ4H,CAAA,GAGX5I,MAAA,CAAOY,IAAA,CAAKwK,CAAA,EAAapK,OAAA,CAAQ,UAAArB,CAAA;YAC3BuL,CAAA,CAAmBvL,CAAA,KACvBkJ,CAAA,CAAuBuC,CAAA,CAAYzL,CAAA,GAAakE,CAAA,CAAclE,CAAA,EAChE;UAAA,IACOyI,CACT;QAAA,CACD;MAAA,CE5Zc,CAAuB2G,CAAA;MAEhC/D,CAAA,GACFA,CAAA,CAAwB;QACtByD,oBAAA,EAAAG,CAAA;QACAF,uBAAA,EAAAG,CAAA;QACAF,sBAAA,EAAAG,CAAA;QACAmC,sBAAA,EAAwB/B;MAAA,MAG1BN,CAAA,IACAE,CAAA,GAAyBK,IAAA,CAAKN,CAAA,GAC9BK,EAAA,GAvEF;IAAA;EAyEF;EG/HM7C,CAAA,GAAyC,SAAA6E,CAAHvR,CAAA;IAKoD,IAJ9FF,CAAA,GAAOE,CAAA,CAAP4M,OAAA;MAAO3M,CAAA,GAAAD,CAAA,CACP8L,aAAA;MAAA3L,CAAA,QAAa,MAAAF,CAAA,GAAG,KAAEA,CAAA;MAAAa,CAAA,GAAAd,CAAA,CAClB4L,oBAAA;MAAArK,CAAA,QAAuB,MAAHT,CAAA,GAAG,CAAE,IAAAA,CAAA;MAGnBU,CAAA,GAAkBmJ,CAAA,CAAe7K,CAAA,EAF9BE,CAAA,CAATkM,SAAA;MAIMxK,CAAA,GAAyBjB,CAAA,CAC7BX,CAAA,CAAQgL,gBAAA,CAAgB,MAAKhJ,CAAA,GAAiC;MAG1DD,CAAA,GAA6C,CAAE;MAC/CE,CAAA,GAAyB;MACzBE,CAAA,GAAuC;IAG7CT,CAAA,CACGN,MAAA,CACC,UAAAlB,CAAA;MACE,OAAAG,CAAA,IACAA,CAAA,CAAcH,CAAA,CAAGuK,OAAA,CAAQuC,MAAA,KACzB3M,CAAA,CAAcH,CAAA,CAAGuK,OAAA,CAAQuC,MAAA,EAASoB,MAAM;IAAA,GAE3C7M,OAAA,CAAQ,UAAArB,CAAA;MACP,IAAIF,CAAA,GAASE,CAAA,CAAGwR,UAAA;MAEhB,IAAIxR,CAAA,CAAGyR,OAAA,EAAS;QACd,IAAMxR,CAAA,GAAgBD,CAAA,CAAGyR,OAAA,CAAO,MAC1BzP,CAAA,GAA6B;QAE/B/B,CAAA,KACFH,CAAA,GAASG,CAAA,CAEb;MAAA;MACA,IAAIE,CAAA,GAAW4B,CAAA,CAAW2P,SAAA,CAAU,UAAA1R,CAAA;QAAA,OAAKA,CAAA,CAAE,OAAOF,CAAM;MAAA;MAAA,CACtC,MAAdK,CAAA,KACF4B,CAAA,CAAWyF,IAAA,CAAK,CAAC1H,CAAA,EAAQA,CAAA,CAAOmL,qBAAA,MAChC9K,CAAA,GAAW4B,CAAA,CAAWqE,MAAA,GAAS,IAEjCvE,CAAA,CAAqB7B,CAAA,CAAGuK,OAAA,CAAQuC,MAAA,IAAW/K,CAAA,CAAW5B,CAAA,EAAU,IAChE8B,CAAA,CAAkBjC,CAAA,CAAGuK,OAAA,CAAQuC,MAAA,IAAWhN,CAC1C;IAAA;IAEF,IAAM0C,CAAA,GAA0BuI,CAAA,CAASvJ,CAAA;MAuCnCwB,CAAA,GAlCAR,CAAA,CAAwBgH,GAAA,CAAI,UAAAxJ,CAAA;QAAsB,IAApBF,CAAA,GAAKE,CAAA;UAAEC,CAAA,GAAQD,CAAA;UAC3CS,CAAA,GAA2B;QAIjC,IACEN,CAAA,IACAA,CAAA,CAAcL,CAAA,CAAMyK,OAAA,CAAQuC,MAAA,KAC5B3M,CAAA,CAAcL,CAAA,CAAMyK,OAAA,CAAQuC,MAAA,EAASoB,MAAA,EACrC;UACA,IAAMpN,CAAA,GAAYe,CAAA,CAAqB/B,CAAA,CAAMyK,OAAA,CAAQuC,MAAA;UAErD3L,CAAA,CAAOV,CAAA,EAA0B;YAC/BmM,OAAA,EAAS9M,CAAA;YACTuO,MAAA,EAAQpM,CAAA,CAAkBnC,CAAA,CAAMyK,OAAA,CAAQuC,MAAA;YACxCwB,aAAA,EAAe;cACbxE,GAAA,EAAK7J,CAAA,CAAS6J,GAAA,GAAMhJ,CAAA,CAAUgJ,GAAA;cAC9BG,IAAA,EAAMhK,CAAA,CAASgK,IAAA,GAAOnJ,CAAA,CAAUmJ,IAAA;cAChCsE,KAAA,EAAOtO,CAAA,CAASsO,KAAA;cAChBC,MAAA,EAAQvO,CAAA,CAASuO;YAAA;UAAA,EAGvB;QAAA;QAEA,OAAO,CACL1O,CAAA,CAAMyK,OAAA,CAAQuC,MAAA,EACd;UACEC,IAAA,EAAM9M,CAAA;UACN+M,OAAA,EAASC,UAAA,CAAW9J,MAAA,CAAO0J,gBAAA,CAAiB/M,CAAA,EAAOkN,OAAA,IAAW;UAC9DoB,wBAAA,EAAA3N;QAAA,EAGN;MAAA,GAEkEO,MAAA,CAChEyJ,CAAA,EACA;IAUF,OAlHwC,UACxCzK,CAAA,EACAF,CAAA;MAEAO,MAAA,CAAOY,IAAA,CAAKjB,CAAA,EAAsBqB,OAAA,CAAQ,UAAAvB,CAAA;QACpCE,CAAA,CAAqBF,CAAA,EAAI0F,OAAA,IAC3BxF,CAAA,CAAqBF,CAAA,EAAI0F,OAAA,IAEvBxF,CAAA,CAAqBF,CAAA,EAAIiJ,cAAA,IAC3B/I,CAAA,CAAqBF,CAAA,EAAIiJ,cAAA,EAAgB,WAEpC/I,CAAA,CAAqBF,CAAA,CAC9B;MAAA,IACAA,CAAA,CAAkBuB,OAAA,CAAQ,UAAArB,CAAA;QACxBA,CAAA,CAAGyO,KAAA,CAAMvB,SAAA,GAAY,IACrBlN,CAAA,CAAGyO,KAAA,CAAMzB,OAAA,GAAU,EACrB;MAAA,EACF;IAAA,CA4FE,CACEzL,CAAA,EACAC,CAAA,CAAgBmM,MAAA,CAAOjM,CAAA,IAGlB;MACLiQ,uBAAA,EAAA3O,CAAA;MACA2I,oBAAA,EAAsBnJ,CAAA,CAAwBgH,GAAA,CAC5C,UAAAxJ,CAAA;QAAU,OAANA,CAAA,CAAM,GAAGuK,OAAA,CAAQuC,MAAO;MAAA;IAAA,CAGlC;EAAA;EC1GMH,CAAA,gBAgBJ;IAAA,SAAA3M,EAAYA,CAAA;MAfJ,KAAA4M,OAAA,gBACAT,aAAA,QAAa,QACbH,oBAAA,IAAuB,GACvB,KAAAK,uBAAA,gBACAJ,KAAA,QAAK,QACLjD,MAAA,QACA,QAAA4C,oBAAA,gBACAE,aAAA,QAAa,QACb8F,QAAA,QAAQ,QAIRtF,UAAA,QACA,QAAAC,OAAA,WAGNpL,CAAA,CAAO,MAAMnB,CAAA,GAEb,KAAK4L,oBAAA,GAAuB,CAAE,GAC9B,KAAKE,aAAA,GAAgB,CAAE,GAEvB,KAAK+F,kBAAA,GAAqB,KAAKA,kBAAA,CAAmBpI,IAAA,CAAK,OACvD,KAAKqI,MAAA,GAAS,KAAKA,MAAA,CAAOrI,IAAA,CAAK,OAC/B,KAAKsI,UAAA,GAAa,KAAKA,UAAA,CAAWtI,IAAA,CAAK,OACvC,KAAKuI,WAAA,GAAc,KAAKA,WAAA,CAAYvI,IAAA,CAAK,KAC3C;IAAA;IAAC,IAAA3J,CAAA,GAAAE,CAAA,CAAAM,SAAA;IAgIA,OAhIAR,CAAA,CAED+R,kBAAA;MACE,KAAKD,QAAA,GAAWlF,CAAA,CAAuC;QACrDE,OAAA,EAAS,KAAKA,OAAA;QACdd,aAAA,EAAe,KAAKA,aAAA;QACpBF,oBAAA,EAAsB,KAAKA;MAAA,EAE/B;IAAA,GAAC9L,CAAA,CACDgS,MAAA,aAAO9R,CAAA,EAAuBF,CAAA;MACxB,KAAK8R,QAAA,KACPnG,CAAA,CAAgB;QACdI,mCAAA,EACE,KAAK+F,QAAA,CAASD,uBAAA;QAChBhG,oBAAA,EAAsB,KAAKiG,QAAA,CAASjG,oBAAA;QACpCI,WAAA,EAAa,KAAKa,OAAA;QAClBhB,oBAAA,EAAsB,KAAKA,oBAAA;QAC3BE,aAAA,EAAe,KAAKA,aAAA;QACpBE,oBAAA,EAAsB,KAAKA,oBAAA;QAC3BhD,MAAA,EAAQ,KAAKA,MAAA;QACbiD,KAAA,EAAO,KAAKA,KAAA;QACZE,aAAA,EAAe,KAAKA,aAAA;QACpBE,uBAAA,EAAyB,KAAKA,uBAAA;QAC9BD,YAAA,EAAc;UACZ4D,QAAA,EAAUhQ,CAAA;UACViQ,OAAA,EAASnQ;QAAA;QAEXwM,UAAA,EAAY,KAAKA,UAAA;QACjBC,OAAA,EAAS,KAAKA;MAAA,gBAEJqF,QAAA,CAEhB;IAAA,GAAC9R,CAAA,CAEDiS,UAAA,aAAA/R,CAAA;MACE,IAAAF,CAAA,GAAOE,CAAA,CAAP4M,OAAA;QACA3M,CAAA,GAAMD,CAAA,CAAN8M,MAAA;QACA3M,CAAA,GAAOH,CAAA,CAAPgN,OAAA;QACAvM,CAAA,GAAST,CAAA,CAATmQ,SAAA;QACArP,CAAA,GAAKd,CAAA,CAALsQ,KAAA;QACA/O,CAAA,GAAevB,CAAA,CAAfoR,eAAA;QACA5P,CAAA,GAAMxB,CAAA,CAANgJ,MAAA;QACAtH,CAAA,GAAO1B,CAAA,CAAP6P,OAAA;QACAhO,CAAA,GAAU7B,CAAA,CAAVqR,UAAA;QACAvP,CAAA,GAAQ9B,CAAA,CAARiO,QAAA;QACAlM,CAAA,GAAO/B,CAAA,CAAPuM,OAAA;QACAvK,CAAA,GAAchC,CAAA,CAAdwG,cAAA;QACAvE,CAAA,GAAUjC,CAAA,CAAVsM,UAAA;QACA9J,CAAA,GAAMxC,CAAA,CAANkO,MAAA;QACAlL,CAAA,GAAUhD,CAAA,CAAV+P,UAAA;QACA1M,CAAA,GAAYrD,CAAA,CAAZyQ,YAAA;MAEA,KAAK3Q,CAAA,EACH,UAAUmS,KAAA,CAAM;MAElB,KAAKhS,CAAA,EACH,MAAM,IAAIgS,KAAA,CAAM;MAElB,IAAM1O,CAAA,GAAa;QACjB+M,KAAA,EAAAxP,CAAA;QACAqP,SAAA,EAAA1P,CAAA;QACAuM,OAAA,EAAA7M,CAAA;QACAiR,eAAA,EAAA7P,CAAA;QACAyH,MAAA,EAAAxH,CAAA;QACAqO,OAAA,EAAAnO,CAAA;QACA2P,UAAA,EAAAxP;MAAA;MAEG0B,CAAA,CAAW+M,KAAA,IAAU/M,CAAA,CAAW4M,SAAA,IAAc5M,CAAA,CAAWyJ,OAAA,IAC5D7L,CAAA,CAAOoC,CAAA,EAAY;QACjB4M,SAAA,GAAW;QACXG,KAAA,GAAO;QACPtD,OAAA,GAAS;MAAA,IAGT/M,CAAA,KACFH,CAAA,CAAQyK,OAAA,CAAQuC,MAAA,GAASoF,MAAA,CAAOjS,CAAA,IAElCH,CAAA,CAAQyK,OAAA,CAAQC,UAAA,GAAaH,IAAA,CAAK8H,SAAA,CAAU5O,CAAA,GAE5C,KAAKuI,aAAA,CAAc7L,CAAA,IAAU;QAC3B8P,UAAA,EAAA/M,CAAA;QACAyN,YAAA,EAAApN,CAAA;QACA4K,QAAA,EAAAnM,CAAA;QACAyK,OAAA,EAAAxK,CAAA;QACAyE,cAAA,EAAAxE,CAAA;QACAsK,UAAA,EAAArK,CAAA;QACAiM,MAAA,EAAA1L;MAAA,CAEJ;IAAA,GAAC1C,CAAA,CAEDkS,WAAA,aAAAhS,CAAA;MACE,IAAAF,CAAA,GAAOE,CAAA,CAAP4M,OAAA;QACA3M,CAAA,GAAMD,CAAA,CAANqO,MAAA;QACAlO,CAAA,GAAOH,CAAA,CAAPgN,OAAA;QACAvM,CAAA,GAAST,CAAA,CAATmQ,SAAA;QACArP,CAAA,GAAKd,CAAA,CAALsQ,KAAA;QACA/O,CAAA,GAAevB,CAAA,CAAfoR,eAAA;MASA,KAAKtR,CAAA,EACH,UAAUmS,KAAA,CAAM;MAElB,KAAKhS,CAAA,EACH,MAAM,IAAIgS,KAAA,CAAM;MAGlB,IAAMzQ,CAAA,GAAgBvB,CAAA,CAAOsK,OAAA,CAAQuC,MAAA;QAC/BpL,CAAA,GAAa;UACjB4O,KAAA,EAAAxP,CAAA;UACAqP,SAAA,EAAA1P,CAAA;UACAuM,OAAA,EAAA7M,CAAA;UACAiR,eAAA,EAAA7P;QAAA;MAEGG,CAAA,CAAW4O,KAAA,IAAU5O,CAAA,CAAWyO,SAAA,IAAczO,CAAA,CAAWsL,OAAA,IAC5D7L,CAAA,CAAOO,CAAA,EAAY;QACjByO,SAAA,GAAW;QACXG,KAAA,GAAO;QACPtD,OAAA,GAAS;MAAA,IAGblN,CAAA,CAAQyK,OAAA,CAAQ6H,aAAA,GAAgB5Q,CAAA,EAChC1B,CAAA,CAAQyK,OAAA,CAAQC,UAAA,GAAaH,IAAA,CAAK8H,SAAA,CAAUzQ,CAAA,CAC9C;IAAA,GAAC1B,CAAA;EAAA,CA1ID;EClCImN,CAAA,GAAsC,IAAIxF,CAAA;EAM1C4F,CAAA,GAAqB,SAAA8E,CAAHrS,CAAA;IAME,IAJxBF,CAAA,GAAME,CAAA,CAANsS,MAAA;MACArS,CAAA,GAAQD,CAAA,CAARuS,QAAA;MAAQpS,CAAA,GAAAH,CAAA,CACRwS,KAAA;MAAA/R,CAAA,QAAQ,MAAHN,CAAA,GAAG,IAACA,CAAA;MACTW,CAAA,GAAUd,CAAA,CAAVsM,UAAA;MAEA/K,CAAA,GAAkDJ,CAAA,CAChD,CAAE,GACFqB,CAAA,CAAcC,QAAA,EACdO,CAAA,CATIhD,CAAA,CAANyS,MAAA;MAM4B/Q,CAAA,GAAiBH,CAAA,CAAjBsH,iBAAA;MAKtBhH,CAAA,GAASsL,CAAA,CAAajF,YAAA,CALX3G,CAAA,CAATmB,SAAA,EAAkBnB,CAAA,CAAPoB,OAAA;IAiCnB,OA3BAd,CAAA,CAAO6E,2BAAA,GAA8BhF,CAAA,GACrCG,CAAA,CAAO0F,WAAA,CAAY;MACjBH,cAAA,EAAgB,SAAAA,CAAApH,CAAA;QACVc,CAAA,IAAYA,CAAA,IAChBd,CAAA,CAAOwF,OAAA,EACT;MAAA;MACAgB,cAAA,EAAgB,SAAAA,CAAAxG,CAAA;QACd,IAAMG,CAAA,GAAYH,CAAA,CAAO4F,eAAA;QACzB,KAAK9F,CAAA,EAAQ,OAAOG,CAAA,CAASE,CAAA;QAC7B,IAAMM,CAAA,GAAgBJ,MAAA,CAAOY,IAAA,CAAKnB,CAAA,EAC/B0J,GAAA,CAAI,UAAAxJ,CAAA;UAAA,OAAS,CACZA,CAAA,EACAwB,CAAA,CAAU1B,CAAA,CAAOE,CAAA,EAAO,IAAIF,CAAA,CAAOE,CAAA,EAAO,IAAIG,CAAA,EAC/C;QAAA,GACAa,MAAA,CAAO,UAAChB,CAAA,EAAKF,CAAA;UAAQ,IAAAG,CAAA;UACpB,OAAOI,MAAA,CAAOuB,MAAA,CAAO5B,CAAA,IAAGC,CAAA,OAAKH,CAAA,CAAK,MAAKA,CAAA,CAAK,IAAEG,CAAA,EAChD;QAAA,GAAG,CAAE;QACPA,CAAA,CAASQ,CAAA,CACX;MAAA;IAAA,IAEEA,CAAA,GACF6C,UAAA,CAAW;MACTzB,CAAA,CAAOmE,WAAA,CAAY,EACrB;IAAA,GAAGvF,CAAA,IAEHoB,CAAA,CAAOmE,WAAA,CAAY,IAEdnE,CACT;EAAA;AAAA,SAAA8K,CAAA,IAAA+F,OAAA,EAAAzQ,CAAA,IAAA0Q,SAAA,EAAAxH,CAAA,IAAAC,WAAA,EAAAC,CAAA,IAAAC,UAAA,EAAAoB,CAAA,IAAA6E,sCAAA,EAAAhG,CAAA,IAAAC,aAAA,EAAAC,CAAA,IAAAC,eAAA,EAAA6B,CAAA,IAAAvE,MAAA,EAAAtH,CAAA,IAAAkR,SAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}